<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>目前共有34篇文章</title>
    <url>/all-posts/</url>
    <content><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="380" height="110" src="//music.163.com/outchain/player?type=0&amp;id=2112262923&amp;auto=1&amp;height=90">
</iframe>
<center>
『 好奇心造就诗人与科学家。』<br>Knowledge of languages is the doorway to wisdom. – Roger Bacon<br><br>
<details class="category_1">
<summary>
人生规划
</summary>
<details open>
<summary>
毕业论文
</summary>
<br> <a href="http://nlpcourse.cn/graduation-thesis">毕业论文准备</a><br>
</details>
</details>
<details class="category_1">
<summary>
代码
</summary>
<details open>
<summary>
Git
</summary>
<br> <a href="http://nlpcourse.cn/git">Git和Github常用操作大全</a><br>
</details>
<details open>
<summary>
文本处理
</summary>
<br> <a href="http://nlpcourse.cn/json">用python处理json数据</a><br> <a href="http://nlpcourse.cn/pdf">PDF文件处理大全</a><br> <a href="http://nlpcourse.cn/txt">纯文本文件的处理</a><br>
</details>
<details open>
<summary>
编辑器
</summary>
<br> <a href="http://nlpcourse.cn/atom">从小白到起飞，一站解决Atom编辑器各种骚操作</a><br>
</details>
</details>
<details class="category_1">
<summary>
未分类
</summary>
<br><a href="http://nlpcourse.cn/all-posts">目前共有33篇文章</a><br> <a href="http://nlpcourse.cn/content">我的电脑文件目录管理</a><br> <a href="http://nlpcourse.cn/hello-world">Hello World</a><br> <a href="http://nlpcourse.cn/hexo-next">Hexo博客Next主题搭建全过程</a><br> <a href="http://nlpcourse.cn/resources">免费好用网站软件资源集锦：从学习、办公到娱乐</a><br> <a href="http://nlpcourse.cn/web-dev-all">网站开发需要的工具：前端和后端</a><br> <a href="http://nlpcourse.cn/wiki-api">好用的API集锦</a><br>
</details>
</details>
<details class="category_1">
<summary>
网站开发
</summary>
<details open>
<summary>
django
</summary>
<br> <a href="http://nlpcourse.cn/django-1">Django网站开发全过程实录-1</a><br>
</details>
<details open>
<summary>
flask
</summary>
<br> <a href="http://nlpcourse.cn/flask-2">一文读懂Flask Web开发实战！</a><br> <a href="http://nlpcourse.cn/flask-api-1">基础：用flask搭建RESTful API</a><br> <a href="http://nlpcourse.cn/flask-api-2">部署Flask开发的API到Heroku</a><br> <a href="http://nlpcourse.cn/flask-api-3">如何在curl和python中使用API</a><br> <a href="http://nlpcourse.cn/flask-web">一个人开发信息检索与抽取网站的全过程</a><br> <a href="http://nlpcourse.cn/flask">flask干货总结</a><br>
</details>
</details>
<details class="category_1">
<summary>
自然语言处理
</summary>
<details open>
<summary>
依存分析
</summary>
<br> <a href="http://nlpcourse.cn/dependency-parsing-1">《自然语言处理综论》第14章-依存分析（上）</a><br> <a href="http://nlpcourse.cn/dependency-parsing-2">《自然语言处理综论》第14章-依存分析（中）</a><br> <a href="http://nlpcourse.cn/dependency-parsing">英文依存句法分析</a><br>
</details>
<details open>
<summary>
信息抽取
</summary>
<br> <a href="http://nlpcourse.cn/information-retrieval-1">《自然语言处理综论》第17章-信息抽取（上）</a><br> <a href="http://nlpcourse.cn/information-retrieval-2">《自然语言处理综论》第17章-信息抽取（中）</a><br> <a href="http://nlpcourse.cn/information-retrieval">信息抽取技术综述</a><br>
</details>
<details open>
<summary>
命名实体识别
</summary>
<br> <a href="http://nlpcourse.cn/named-entity-recognition-2">英文文献的命名实体识别（中）</a><br> <a href="http://nlpcourse.cn/named-entity-recognition">英文文献的命名实体识别（上）</a><br>
</details>
<details open>
<summary>
正则表达式
</summary>
<br> <a href="http://nlpcourse.cn/regex-1">正则表达式进阶</a><br>
</details>
<details open>
<summary>
词性标注
</summary>
<br> <a href="http://nlpcourse.cn/pos-tagging">英文词性标记（POS Tagging）</a><br>
</details>
<details open>
<summary>
语料库
</summary>
<br> <a href="http://nlpcourse.cn/corpus">语料库资源大全</a><br>
</details>
</details>
<details class="category_1">
<summary>
语言学
</summary>
<details open>
<summary>
心理语言学
</summary>
<br> <a href="http://nlpcourse.cn/psycho-linguistics">心理语言学：资源和知识整理</a><br>
</details>
<details open>
<summary>
语言测试
</summary>
<br> <a href="http://nlpcourse.cn/language-assessment">语言测试Syllabus</a><br> <a href="http://nlpcourse.cn/language-assessment2">语言测试glossary</a><br>
</details>
</details>
<br><br>关注公众号：鸽婆打字机！风里雨里，鸽鸽陪你~
</center>
<p><img align="center" width="120" height="120" alt="微信公众号：鸽婆打字机" src="https://i.loli.net/2021/03/04/dXVUZiRfW2o7wCy.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>《自然语言处理综论》第17章-信息抽取（中）</title>
    <url>/information-retrieval-2/</url>
    <content><![CDATA[<center>
<i>原文链接：https://web.stanford.edu/~jurafsky/slp3/17.pdf</i> <br> <i>译者：鸽鸽（自己学习使用，非商业用途）</i>
</center>
<hr />
<blockquote>
<p><em>I am the very model of a modern Major-General,</em> <em>I’ve information vegetable, animal, and mineral,</em> <em>I know the kings of England, and I quote the fights historical</em> <em>From Marathon to Waterloo, in order categorical...</em></p>
<p>Gilbert and Sullivan, Pirates of Penzance</p>
</blockquote>
<h1 id="关系提取">17.1 关系提取</h1>
<p>假设我们已经检测到了样本文本中的命名实体（也许使用了第8章的技术），并想识别出检测到的实体之间的关系：</p>
<blockquote>
<p>以高油价为由，[ORG联合航空公司]表示，[时间周五]它已将飞往一些同样由低成本航空公司服务的城市的航班的票价每往返提高了[MONEY 6美元]。发言人[per蒂姆-瓦格纳]表示，[ORG美国航空]是[ORG AMR Corp.]的一个单位，立即配合这一举措。ORG美联航]，[ORG UAL Corp.]的一个单位，说增加生效[时间周四]，适用于它与折扣航空公司竞争的大多数航线，如[LOC芝加哥]到[LOC达拉斯]和[LOC丹佛]到[LOC旧金山]。<em>(机翻结果)</em></p>
</blockquote>
<p><img src="https://i.loli.net/2021/03/18/senloyDcQAGipId.png" width="700"/></p>
<span id="more"></span>
<hr />
<p><strong>本章剩余内容见：《自然语言处理综论》第17章-信息抽取（下）</strong></p>
]]></content>
      <categories>
        <category>自然语言处理</category>
        <category>信息抽取</category>
      </categories>
      <tags>
        <tag>nlp</tag>
        <tag>IR</tag>
      </tags>
  </entry>
  <entry>
    <title>Git和Github常用操作大全</title>
    <url>/git/</url>
    <content><![CDATA[<blockquote>
<p>Git是目前世界上最先进的分布式版本控制系统（没有之一）。Git的功能有版本控制（版本管理、远程仓库、分支协作）。GitHub是一个非常流行的全球代码托管平台.</p>
</blockquote>
<p>参考：<a href="https://blog.csdn.net/Python_Ai_Road/article/details/109476021">30分钟吃掉Git和GitHub常用操作</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line">git add -A </span><br><span class="line">git add . </span><br><span class="line">git add <span class="built_in">next</span>/_config.yml</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">&quot;comment&quot;</span> </span><br><span class="line"></span><br><span class="line">git remote add origin https://github.com/XX/XX</span><br><span class="line">git push -u origin master</span><br><span class="line"></span><br><span class="line">git clone https://github.com/XX/XX  ../XX</span><br><span class="line">    </span><br><span class="line">git remote -v</span><br><span class="line">git remote rm origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除git</span></span><br><span class="line">rm -rf .git</span><br><span class="line"></span><br><span class="line">git reset HEAD^ <span class="comment">#可以回退到上一个版本。</span></span><br><span class="line">git reset HEAD^^ <span class="comment">#可以回退到上上个版本。</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
]]></content>
      <categories>
        <category>代码</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>从小白到起飞，一站解决Atom编辑器各种骚操作</title>
    <url>/atom/</url>
    <content><![CDATA[<blockquote>
<p>一站到底解决IDE搭建问题！从基础设置、插件安装、snippets填充、到github版本控制、代码调试……本文将不断更新以求完善！</p>
</blockquote>
<h2 id="安装文本编辑器atom">安装文本编辑器Atom</h2>
<p>入坑Sublime、VSCode无数次后，还是回头选择了Atom IDE，因为它颜值惊艳、操作便捷、界面简单，除了许多编辑器都有的<strong>代码折叠</strong>和<strong>自动补全</strong>，还自带原生Markdown支持！！！这漂亮的实时预览和代码高亮真让人春心荡漾！并且，插件非常丰富！ <span id="more"></span> 于是，果断选择Atom作为本博主的<strong>创作神器</strong>，为Python开发之旅保驾护航！</p>
<p>官网一键安装：<a href="https://atom.io/">AtomSetup-x64</a></p>
<p>确认操作系统无误，点击download，打开下载好的AtomSetup-x64.exe，极速体验！</p>
<figure>
<img src="https://pic2.zhimg.com/v2-e2e305deea69303a19d71da452138945_b.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p><em>缺点是启动速度不如sublime</em></p>
<h2 id="安装插件失足卡顿的惨痛经历">安装插件：失足卡顿的惨痛经历</h2>
<p>此时你一定急不可耐地冲向Install a Package，风风火火地下载了一堆插件：minimap用来预览全貌，atom-beautify用来格式化（想到令人头痛的html），file-icons小图标好可爱呀，material主题貌似很热门吼，markdown-preview-enhanced吊打我的Typora呢（Typora是我常用的md编辑器），script可以运行代码嗷，autocomplete-python自动补全呢，python-autopep8调格式也不错哟，linter-flake8检查语法错误呢，Hydrogen简直是jupyter的孪生姐妹……你在界面乐此不疲地倒腾……</p>
<p>A few hours later...</p>
<p>突然，你意识到此时的atom一片混乱卡顿缓慢，再也不是当初清纯活泼的模样！你蹙起眉，两行清泪润湿了乌黑的下眼眶！</p>
<p>一怒之下，你卸载了atom，并剿杀了一切软件残留：<a href="https://cn.compbs.com/how-uninstall-atom-windows">如何彻底删除atom</a>，<a href="https://www.coder.work/article/552966">如何更彻底地删除</a>！</p>
<h2 id="正确的打开方式是什么">正确的打开方式是什么？</h2>
<p>正文从这里开始！</p>
<p>那么，配置环境和安装插件的正确方式是什么呢？</p>
<ol type="1">
<li>打开Editor Settings，<strong>勾选Scroll Past End和Show Indent Guide，设置Tab Length为4，Font Size为20</strong>，护眼第一啦！</li>
<li>主题我喜欢atom自带的<strong>One Light，</strong>打开themes-&gt;One Light UI-&gt;Settings-&gt;<strong>Font Size设置为15</strong>，语法主题我选择<strong>Monokai</strong>。还是为了护眼！码字时还可以随时ctrl+和ctrl-调整字体大小。</li>
<li>下载插件：<strong>minimap、file-icons、atom-beautify、markdown-preview-enhanced、python-autopep8、markdown-writer</strong>。大道至简，这是我目前选择的基础组件，可能以后会更新！进入python-autopep8-&gt;Settings，勾选Format On Save。</li>
</ol>
<figure>
<img src="https://pic3.zhimg.com/v2-62a1e257adc2ca9978dee539798d3342_b.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p><em>atom-material-syntax-dark语法主题也好看，只是Python语法高亮略丑，就不放了</em></p>
<p>个人认为，<strong>编辑器只需提供高效、舒适的代码体验即可</strong>，各种花里胡哨的功能比较鸡肋，反而会加重的负担。</p>
<p><a href="https://atom.io/themes/list?direction=desc&amp;sort=downloads">atom热门主题排行榜</a>：material、monokai、seti。</p>
<p><a href="https://atom.io/packages/list?direction=desc&amp;sort=stars">atom热门插件排行榜</a>：minimap、file-icons、atom-beautify、linter、script。</p>
<p><strong>下面重点来了，下载插件的方式！！！</strong></p>
<p>打开cmd，执行以下命令（apm是Atom Package Manager的缩写）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install autopep8</span><br><span class="line">apm install monokai, minimap, file-icons, atom-beautify, markdown-preview-enhanced, python-autopep8</span><br></pre></td></tr></table></figure>
<p>如果一起下载速度太慢，也可以apm install <package_name>分开下载。</p>
<p>晃悠了一杯茶的时间，已经全部done啦！Voila！</p>
<p>重启Atom，Ctrl+Shift+P打开Settings-&gt;Packages，是不是整齐陈列着我们要的插件呢？（不知为什么ctrl+逗号不能打开settings）</p>
<p>码上行动叭！！！</p>
<figure>
<img src="https://pic3.zhimg.com/v2-873f85f52366e6ab44b3eda548930102_b.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p><em>这是最终的windows界面</em></p>
<p>另外，有童鞋选择github上面的源码git clone，然后cd进文件夹、npm install来安装，也不错呢~</p>
<p>对了，卸载插件的话，apm uninstall <package_name> 就好啦！</p>
<p>----------2021-03-04更新---------</p>
<h2 id="代码填充功能snippets">代码填充功能Snippets</h2>
<p>当我们需要重复使用一套模板时，不如试试<a href="https://www.jianshu.com/p/2ee34d8da142">Atom自带的Snippets代码块功能</a>，这种快捷填充，省去了重复码字的时间。打开终端输入下面指令，用atom打开snippets.cson：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">atom C:\Users\用户名\.atom\snippets.cson</span><br></pre></td></tr></table></figure>
<p>可以看到目前空空如也，在这个文件里面打“snip”，然后敲下tab键，会跳出来用于创建snippets的snippets（像套娃一样耶）。换上你想存储的代码块吧，示例如下：</p>
<figure>
<img src="https://pic1.zhimg.com/v2-d5d6ec618868382045aa1044eae6e988_b.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>以后每次想插入代码块，直接输我们预设的“暗号”，然后按tab键即可，迅如闪电呀！</p>
<p><strong>注意</strong>：snippets只在相应语言中有效！并且，除了常见的Python、Java、JS等，<strong>其他有些语言是不支持snippets功能的</strong>，此时有两种方法：</p>
<ol type="1">
<li>通过apm install language-语言，安装相应语言的支持包；</li>
<li>将.source.语言 改成* 。</li>
</ol>
<p>我比较建议第二种方法。</p>
<p>另外，mardown中输入table、img、L等按下tab键，可以快捷插入表格、图片、链接等。</p>
<figure>
<img src="https://pic2.zhimg.com/v2-4d43fef791abc2195246b9621b37f4b9_b.gif" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>成功啦，美滋滋~</p>
<h2 id="代码调试">代码调试</h2>
<p>暂时用不到，先占个坑，下次完善！</p>
<h2 id="使用github远程版本控制">使用Github远程版本控制</h2>
<p>又解锁atom连接github和git啦！赶紧更新日志！</p>
<p>话说，atom本来就是github开发的编辑器好嘛！我们来测试下好用吗！</p>
<p>Github注册无须多言吧，我创建了一个新的repository，命名blog，用来云端存储我的写作素材与稿件。这时我们看到页面提供了一系列指令：</p>
<figure>
<img src="https://pic1.zhimg.com/v2-6daf82cf178c578fd4cf4c19da68cb88_b.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p><em>这里其实是blog仓库，但我为了演示又重新建了名为test的仓库</em></p>
<p>我们只需要打开windows系统的git bash，一句一句输入。我输入的是以下指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd blog</span><br><span class="line">echo &quot;#blog&quot; &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;MissFreak&#x2F;blog.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
<p>成功后，在Atom打开blog这个文件夹（也就是你想要进行版本控制的项目），我们看到右侧显示github登录界面，提示我们打开github.atom.io，复制GitHub token到Atom的登录表单。Success！</p>
<figure>
<img src="https://pic1.zhimg.com/v2-6e1aa37602728c2eb6bdc8701b013270_b.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>接下来就随心所欲地增改文件，然后stage all-&gt;commit to main-&gt;pull 吧！</p>
<p>终于不用在终端敲指令，也可以和Github Desktop说拜拜啦！</p>
<figure>
<img src="https://pic4.zhimg.com/v2-713ea328565e6babf7e9559c20bc2e8b_b.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p><strong>参考资料：</strong><a href="https://flight-manual.atom.io/using-atom/sections/github-package/">Atom Documentation-GitHub package</a></p>
<h2 id="你可能不知道的快捷键">你可能不知道的快捷键</h2>
<table>
<thead>
<tr class="header">
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>在所有项目文件中查找字符串</td>
<td>Ctrl + Shift + f</td>
</tr>
<tr class="even">
<td>打开导航栏的File、Edit、View等</td>
<td>Alt+导航栏首字母</td>
</tr>
<tr class="odd">
<td>向上/下移动该行</td>
<td>Ctrl + up/down</td>
</tr>
</tbody>
</table>
<p><a href="https://yanyinhong.github.io/2017/07/23/Atom-keyboard-shortcuts/">Windows环境下的Atom快捷键</a></p>
<p><a href="https://www.itread01.com/content/1549978931.html">mac下Atom编辑器快捷键大全</a></p>
<figure>
<img src="https://pic4.zhimg.com/v2-e0ed2bebdccf67e44a7c2bb61ff7b26b_b.gif" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p><em>在项目所有文件中搜索“正则”</em></p>
<p>----------2021-03-04更新---------</p>
<h2 id="html神器">HTML神器</h2>
<p>又屁颠屁颠跑来更新啦，虽然只有我一个人自娱自乐。</p>
<p>Python开发网站离不开的插件，亲测好用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apm install atom-html-preview, pigments, highlight-selected, autoclose-html-plus, color-picker, color-tabs</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<figure>
<img src="https://pic3.zhimg.com/v2-692783c713218dc64a68c8faca88c096_b.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="markdown神器">Markdown神器</h2>
<p>还有，大家赶紧把这款神器mardown-preview-enhanced用起来吧，功能齐全到不可想象！<strong>可以折叠一级、二级、三级标题，专注于当前标题下的内容！（但是我刚用了貌似会卡）</strong></p>
<p>可以运行代码，并渲染运行结果：</p>
<figure>
<img src="https://pic3.zhimg.com/v2-12f773fb3a40b67afa0a432aa3dbc9b2_b.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>各种流程图、结构图：</p>
<figure>
<img src="https://pic2.zhimg.com/v2-9c4fd8ff9abd02d7cbb3f6566bf0549d_b.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>甚至制作幻灯片：</p>
<figure>
<img src="https://pic4.zhimg.com/v2-cdcf68324e69b094ea314250405b9e9b_b.gif" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>还有太多亮瞎眼的操作不一一列举，详情请戳：https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/</p>
<p>VScode也可以用~真的很想把sublime扔进垃圾桶了！虽然sublime打开速度确实快！</p>
<h2 id="terminal-神器">Terminal 神器</h2>
<p>我又发现了一款终端程序包，terminal-plus！可以更改主题、查看终端当前运行的命令进程！用颜色标记状态图标和排序！从文本编辑器插入并运行文本！还有太多功能大家自己查阅！再次挖到宝贝啦！</p>
<p><a href="https://github.com/jeremyramin/terminal-plus">jeremyramin/terminal-plus</a></p>
<figure>
<img src="https://pic1.zhimg.com/v2-a579e162c502f89da0d9036ac21abfb8_b.png" alt="img" /><figcaption aria-hidden="true">img</figcaption>
</figure>
<p>总结：我目前安装的插件和主题如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── atom-beautify@0.33.4</span><br><span class="line">├── atom-html-preview@0.2.6</span><br><span class="line">├── autoclose-html-plus@0.27.2</span><br><span class="line">├── color-picker@2.3.0</span><br><span class="line">├── color-tabs@0.1.8</span><br><span class="line">├── file-icons@2.1.46</span><br><span class="line">├── highlight-selected@0.17.0</span><br><span class="line">├── markdown-preview-enhanced@0.18.8</span><br><span class="line">├── markdown-writer@2.11.11</span><br><span class="line">├── minimap@4.39.9</span><br><span class="line">├── monokai@0.27.0</span><br><span class="line">├── pigments@0.40.6</span><br><span class="line">├── python-autopep8@0.1.3</span><br><span class="line">└── python-tools@0.6.9</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>代码</category>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>atom</tag>
        <tag>editor</tag>
      </tags>
  </entry>
  <entry>
    <title>语料库资源大全</title>
    <url>/corpus/</url>
    <content><![CDATA[<h1 id="现存语料库">现存语料库</h1>
<h2 id="词语">词语</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">条目</th>
<th style="text-align: left;">长度</th>
<th style="text-align: left;">数量</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">汉字</td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">16142</td>
</tr>
<tr class="even">
<td style="text-align: left;">词语</td>
<td style="text-align: left;">2~3</td>
<td style="text-align: left;">264434</td>
</tr>
<tr class="odd">
<td style="text-align: left;">成语</td>
<td style="text-align: left;">4~5</td>
<td style="text-align: left;">31648</td>
</tr>
<tr class="even">
<td style="text-align: left;">歇后语</td>
<td style="text-align: left;">6+</td>
<td style="text-align: left;">14032</td>
</tr>
</tbody>
</table>
<p>新华网成语、歇后语和词语：https://github.com/pwxcoo/chinese-xinhua</p>
<p>查询接口：https://github.com/netnr/zidian</p>
<p>近反义词：https://github.com/guotong1988/chinese_dictionary</p>
<span id="more"></span>
<h2 id="句子">句子</h2>
<p>微博短句、句子迷</p>
<h3 id="idea">idea</h3>
<p>除了欣赏，也可以收集美句美文，并表达不同心情和志趣。</p>
<h2 id="文章">文章</h2>
<p>新闻：https://github.com/aceimnorstuvwxz/toutiao-text-classfication-dataset</p>
<p>微信公众号语料库：https://github.com/nonamestreet/weixin_public_corpus</p>
<p>每行文章，是JSON格式，名称是微信公众号名字，帐户是微信公众号ID，标题是译文，内容是正文。</p>
<h3 id="idea-1">idea</h3>
<p>文本分类！主题建模！可以按照风格分类！</p>
<h2 id="名字">名字</h2>
<p>豆瓣影视和书籍的名字</p>
<p>微信、知乎文章标题</p>
<p>书名号</p>
<h3 id="idea-2">idea</h3>
<p>抓取所有名字，动态展现，且按照不同风格分类！就叫标题网！</p>
<p>功能：帮助大家取名、让标题更吸引人、更有文采！并研究怎样的文章更吸引读者。</p>
<h2 id="诗词">诗词</h2>
<p>中华古诗词数据库：</p>
<p>https://github.com/chinese-poetry/chinese-poetry</p>
<h2 id="维基百科">维基百科</h2>
<p>信息检索？</p>
<h2 id="学术语料">学术语料</h2>
<p>信息检索？</p>
<h1 id="抓取原则">抓取原则</h1>
<h2 id="频率tf-idf">频率tf-idf</h2>
<h2 id="打分">打分</h2>
<ul>
<li>通过文章和书籍的阅读量和点赞</li>
</ul>
]]></content>
      <categories>
        <category>自然语言处理</category>
        <category>语料库</category>
      </categories>
      <tags>
        <tag>corpus</tag>
      </tags>
  </entry>
  <entry>
    <title>《自然语言处理综论》第14章-依存分析（上）</title>
    <url>/dependency-parsing-1/</url>
    <content><![CDATA[<center>
<i>原文链接：https://web.stanford.edu/~jurafsky/slp3/14.pdf</i> <br> <i>译者：鸽鸽（自己学习使用，非商业用途）</i>
</center>
<hr />
<p>前两章的重点是<strong>上下文无关语法</strong>（context-free grammars）<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，及其用于自动生成基于成分的表征。 我们在这里介绍另一种称为<strong>依存语法</strong>（dependency grammars）的语法形式主义派系，它在当代语音和语言处理系统中极其重要。 在这些形式主义中，短语成分（phrasal constituents）和短语结构规则（phrase-structure rules）并不直接发挥作用。相反，一个句子的句法结构，仅根据句中单词（或词元lemmas）以及单词间存在的一组关联的有向二元语法关系来描述。</p>
下图展示了标准的依存分析风格的句法图示。
<center>
<img src="https://i.loli.net/2021/03/17/3XaE6umlQIgpZrs.png"  alt="" width="700" />
</center>
<p>在句子上方，用从<strong>头部</strong>（heads）到<strong>依存项</strong>（dependents）的有向的标记弧来表示单词之间的关系。我们称之为<strong>类型依存结构</strong>（typed dependency structure），因为标签是从固定的语法关系清单中提取的。它还包括一个根（root）节点，显式地标记句法树的根，即整个结构的中心。</p>
<span id="more"></span>
<p>图14.1显示了与第12章中给出的相应短语结构分析相同的依存分析及树形结构。注意依存分析中没有对应短语成分或词汇类别的节点；<strong>其内部结构仅由句子中词汇项之间的定向关系组成。</strong>这些关系<strong>直接编码重要信息</strong>，这些信息往往隐藏在更复杂的短语结构分析中。例如，动词prefer的<strong>论元</strong>（arguments）在依存结构中直接链接到它，而在短语结构树中它们与主动词的连接不那么紧密。类似地，flight的修饰语morning和Denver在依存结构中直接与之链接。</p>
<center>
<img src="https://i.loli.net/2021/03/17/c1yRPAQCefvESZW.png"  alt="" width="700" />
</center>
<p><strong>依存语法的一个主要优势是能够处理形态丰富、词序相对自由（free word order）的语言。</strong>例如，捷克语的词序可能比英语灵活得多；宾语可能出现在位置状语之前或之后。短语结构语法会需要为解析树中每个可能出现这样一个状语短语的位置单独制定一条规则。基于依存关系的方法只用一种连接类型来表示这种特殊的状语关系。因此，依存分析的方法抽象出了词序信息，只表示解析所需的信息。</p>
<p>使用依存分析的另一个实际性的动机是，<strong>头部-依存（head-dependent）关系</strong>提供了一种近似于谓词及其论元之间的语义关系，这使得它们对指代消歧、自动问答和信息提取之类的许多应用都能产生直接的帮助。基于成分（constituent-based）的语法解析也提供了类似的信息，但通常必须通过诸如第12章讨论的中心语规则等技术从树中提炼出来。</p>
<p>在下面的章节，我们将更详细地讨论依存分析中使用的关系清单，以及这些依存结构的形式基础。然后我们将继续讨论用于自动生成这些结构的主流算法派系。最后，我们将讨论如何评估依存分析器，并指出它们在语言处理中应用的一些方式。</p>
<h1 id="依存关系">14.1 依存关系</h1>
<p>传统语言学的语法关系概念为构成这些依存结构的二元语法关系提供了基础。这些头关系（head relations）的参数由一个<strong>头部</strong>（heads）和一个<strong>依存项</strong>（dependents）组成。在第12章和附录C中，我们已经在成分结构的语境下中讨论过头部的依存项这个概念。在那里，一个成分的头部是一个更大成分的中心组织词（例如名词短语中的关键名词，或动词短语中的动词）。成分中其余的词都是其头部的直接或间接的依存项。在基于依存关系的方法中，通过直接将头部与紧靠头部的词连接起来，绕过成分结构，使头部-依存关系变得明确。</p>
<p>除了指定头部-依存对，依存语法还允许我们根据依存项相对于头部的作用，进一步划分语法关系种类或<strong>语法功能</strong>（grammatical function）。我们熟悉的主语、直接宾语和间接宾语等概念都是可能会想到的关系种类。在英语中，这些概念虽然与一个词在句中的位置和成分类型密切相关，但不起决定性作用，因此与短语结构树中提供的信息重复累赘。然而，在更灵活的语言中，直接编码这些语法关系中的信息是至关重要的，因为基于短语的成分句法提供的帮助很小。</p>
<p>毫不奇怪，语言学家们已经发明了远远超出我们熟悉的主语和宾语概念的关系分类学。虽然不同的理论之间大相径庭，但有足够的共性使其发展出一个在计算上有用的标准。<strong>通用依存关系</strong>（Universal Dependencies）项目（Nivre et al.，2016）提供了一个语言驱动的、利于计算的、跨语言适用的依存关系清单。</p>
<table>
<thead>
<tr class="header">
<th>Clausal Argument Relations</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NSUBJ</td>
<td>Nominal subject</td>
</tr>
<tr class="even">
<td>DOBJ</td>
<td>Direct object</td>
</tr>
<tr class="odd">
<td>IOBJ</td>
<td>Indirect object</td>
</tr>
<tr class="even">
<td>CCOMP</td>
<td>Clausal complement</td>
</tr>
<tr class="odd">
<td>XCOMP</td>
<td>Open clausal complement</td>
</tr>
<tr class="even">
<td><strong>Nominal Modifier Relations</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="odd">
<td>NMOD</td>
<td>Nominal modifier</td>
</tr>
<tr class="even">
<td>AMOD</td>
<td>Adjectival modifier</td>
</tr>
<tr class="odd">
<td>NUMMOD</td>
<td>Numeric modifier</td>
</tr>
<tr class="even">
<td>APPOS</td>
<td>Appositional modifier</td>
</tr>
<tr class="odd">
<td>DET</td>
<td>Determiner</td>
</tr>
<tr class="even">
<td>CASE</td>
<td>Prepositions, postpositions and other case markers</td>
</tr>
<tr class="odd">
<td><strong>Other Notable Relations</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td>CONJ</td>
<td>Conjunct</td>
</tr>
<tr class="odd">
<td>CC</td>
<td>Coordinating conjunction</td>
</tr>
</tbody>
</table>
<center>
<i>图14.2 通用依存关系集中的部分依存关系 (de Marneffe et al., 2014)</i>
</center>
<p>图14.2显示了这项工作中的关系子集。图 14.3 提供了一些例句来说明选定的关系。通用依存方案中所有关系的来由超出了本章的范围，但常用关系的核心集可以分成两组：描述与谓语（通常是动词）有关的句法角色的子句关系（clausal relations），以及对头部修饰词进行分类的修饰关系（modifier relations）。</p>
<table>
<thead>
<tr class="header">
<th>Relation</th>
<th>Examples with <em>head</em> and dependent</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>NSUBJ</td>
<td><strong>United</strong> <em>canceled</em> the flight.</td>
</tr>
<tr class="even">
<td>DOBJ</td>
<td>United <em>diverted</em> the <strong>flight</strong> to Reno.</td>
</tr>
<tr class="odd">
<td></td>
<td>We <em>booked</em> her the first <strong>flight</strong> to Miami.</td>
</tr>
<tr class="even">
<td>IOBJ</td>
<td>We <em>booked</em> <strong>her</strong> the flight to Miami.</td>
</tr>
<tr class="odd">
<td>NMOD</td>
<td>We took the <strong>morning</strong> <em>flight</em>.</td>
</tr>
<tr class="even">
<td>AMOD</td>
<td>Book the <strong>cheapest</strong> <em>flight</em>.</td>
</tr>
<tr class="odd">
<td>NUMMOD</td>
<td>Before the storm JetBlue canceled <strong>1000</strong> <em>flights</em>.</td>
</tr>
<tr class="even">
<td>APPOS</td>
<td><em>United</em>, a <strong>unit</strong> of UAL, matched the fares.</td>
</tr>
<tr class="odd">
<td>DET</td>
<td><strong>The</strong> <em>flight</em> was canceled.</td>
</tr>
<tr class="even">
<td></td>
<td><strong>Which</strong> <em>flight</em> was delayed?</td>
</tr>
<tr class="odd">
<td>CONJ</td>
<td>We <em>flew</em> to Denver and <strong>drove</strong> to Steamboat.</td>
</tr>
<tr class="even">
<td>CC</td>
<td>We flew to Denver <strong>and</strong> <em>drove</em> to Steamboat.</td>
</tr>
<tr class="odd">
<td>CASE</td>
<td>Book the flight <strong>through</strong> <em>Houston</em>.</td>
</tr>
</tbody>
</table>
<center>
<i>Figure 14.3 Examples of core Universal Dependency relations.</i>
</center>
<p>参考以下例句，子句关系NSUBJ和DOBJ分别表示主语和谓语cancel的直接宾语，而NMOD、DET和CASE关系表示名词flights和Houston的修饰语。</p>
<p><img src="https://i.loli.net/2021/03/17/XgwzFkLVSdaIfDj.png" /></p>
<h1 id="依存形式主义">14.2 依存形式主义</h1>
<p>在最普通的形式中，我们讨论的依存关系结构仅仅是有向图，即由一组顶点<span class="math inline">\(V\)</span>和一组有序的顶点对<span class="math inline">\(A\)</span>组成的结构<span class="math inline">\(G=(V, A)\)</span>，我们称之为弧（arcs）。</p>
<p>大多数情况下，我们假设顶点集<span class="math inline">\(V\)</span>完全对应于给定句子中单词的集合。然而，它们也可能对应于标点符号，或者当处理形态复杂的语言时，顶点集可能由词干和词缀组成。弧线集<span class="math inline">\(A\)</span>捕获了<span class="math inline">\(V\)</span>中元素之间的头部-依存关系和语法功能关系。</p>
<p>对这些依存结构的进一步限制是针对底层语法理论或形式主义的。其中比较常见的限制是，这些结构必须是连接的、有一个指定的根节点，并且是无环或平面的。与本章讨论的解析方法最相关的是对有根树的常见的、以计算为目的的限制。也就是说，<strong>依存树</strong>（dependency tree）是一个满足以下约束的有向图。</p>
<ol type="1">
<li>有一个指定的根结点，它没有传入弧。</li>
<li>除根节点外，每个顶点恰好有一个传出弧。</li>
<li>从根节点到<span class="math inline">\(V\)</span>中的每个顶点有一条唯一的路径。</li>
</ol>
<p>综上所述，这些约束条件保证了每个词都有一个头，依存结构是连接的，并且有唯一的根节点，从这个根节点可以沿着唯一的定向路径到句子中的每个词。</p>
<h2 id="投射性">14.2.1 投射性</h2>
<p><strong>投射性</strong>（projectivity）的概念施加了一个额外的约束条件，这个约束条件来自于输入（input）中词的顺序。如果在句子中<strong>存在一条从头部到位于头部和依存项之间的每个词的路径</strong>，那么就说这条从头部到依存项的弧线具有投射性。如果组成依存树的所有弧线都有投射性，那么就可以说它是投射的。到目前为止，我们看到的所有依存树都是投射的。然而，有许多完全合乎规则的结构会生成非投射树，特别是在词序相对灵活的语言中。</p>
<p>请看下面的例子。</p>
<p><img src="https://i.loli.net/2021/03/17/2Jicfx1AThkBFId.png" /></p>
<p>在这个例子中，从flight到它的修饰词was的弧线是非投射的，因为从flight到中间的单词this和morning没有路径。正如我们从这张图中看到的，投射性（和非投射性）可以通过画树的方式来检测。<strong>如果能画出没有交叉边的依存树，那么它就是投射性的。</strong>在这里，如果不跨越连接morning和它的头部的弧线，就无法将flight和它的依存项was联系起来。</p>
<p>我们对投射性的关注来自于两个相关的问题。首先，最广泛使用的英语依存关系树库是通过使用中心语查找规则从短语结构树库中自动导出的（第12章）。以这种方式生成的树是保证投射性的，因为它们是由上下文无关语法生成的。第二，最广泛使用的一系列解析算法存在计算上的限制。第14.4节中讨论的基于转换的方法只能生成投射树，因此任何具有非投射结构的句子都必然会出错。这个限制是第14.5节中描述的更灵活的基于图的解析方法的动机之一。</p>
<h1 id="依存树库">14.3 依存树库</h1>
<p>与基于成分的方法一样，树库（treebanks）在依存分析器（dependency parsers）的开发和评估中起着至关重要的作用。<strong>依存树库</strong>（dependency treebanks）的创建方法与第12章中讨论的方法类似——让人类标注者直接为给定的语料库生成依存结构，或者使用自动解析器（automatic parsers ）提供初始解析，然后让标注者手动修正这些解析器。我们也可以用一个确定性过程<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>（deterministic process）通过标注中心语规则将现有的基于成分的树库翻译成依存树。</p>
<p>大多形态丰富的语言（如捷克语、印地语和芬兰语）都已经建立了直接标注的依存树库用于依存分析，其中捷克语的Prague依存树库（Bejcek et al., 2013）是最著名的工作。主流英语依存树库主要是从现有资源中提取出来的，比如Penn树库的华尔街日报部分（Marcus等人，1993）。最近的OntoNotes项目（Hovy et al. 2006, Weischedel et al. 2011）扩展了这种方法，超越了传统的新闻文本，涵盖了英语、汉语和阿拉伯语的电话对话、网络日志、usenet新闻组、广播和脱口秀。</p>
<p>从成分结构到依存结构的翻译过程有两个子任务：识别结构中所有的头部-依存关系，以及正确识别这些关系的种类。第一个任务主要依赖于第12章中讨论的中心语规则（head rules）的使用，这些规则最早是为词汇化概率解析器（ lexicalized probabilistic parsers）而开发的(Magerman 1994, Collins 1999, Collins 2003)。下面是Xia和Palmer（2001）提出的一个简单有效的算法。</p>
<ol type="1">
<li>使用适当的中心语规则，标记短语结构中每个节点的头部子节点。</li>
<li>在依存结构中，让每个非头部子节点的头部依存于头部子节点的头部。</li>
</ol>
<p>当一个短语结构解析包含了额外的语法关系和函数标签形式的信息时，如在Penn Treebank的情况下，这些标签可以用来标记生成的树的边。当应用于图14.4中的解析树时，这种算法将产生例14.4中的依存结构。这些提取方法的主要缺点是它们受到原始结构树中存在的信息的限制。其中最重要的问题是未能将形态学信息与短语结构树整合在一起，不能轻易地表示非宾语结构，以及大多数名词短语缺乏内部结构，这反映在大多数树库语法通常所使用的平面规则中。由于这些原因，除了英语之外，大多数依存树库都是直接靠人类标注者开发的。</p>
<hr />
<p><strong>本章剩余内容见：<a href="http://nlpcourse.cn/dependency-parsing-2/">《自然语言处理综论》第14章-依存分析（中）</a></strong></p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>也称为短语结构语法 (phrase-structure grammar)<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>译者注：对应<a href="https://baike.baidu.com/item/随机过程">随机过程（<em>Stochastic Process</em>）</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>自然语言处理</category>
        <category>依存分析</category>
      </categories>
      <tags>
        <tag>nlp</tag>
        <tag>dependency</tag>
      </tags>
  </entry>
  <entry>
    <title>英文依存句法分析</title>
    <url>/dependency-parsing/</url>
    <content><![CDATA[<blockquote>
<p>依存分析是根据句子中单词之间的依存关系来分析句子语法结构的过程。</p>
</blockquote>
<p>在依存分析中，各种标签代表了一个句子中两两词语之间的关系。例如，在'rainy weather'这个短语中，rainy是修饰名词weather的形容词。weather -&gt; rainy 形成了依存关系，其中weather是head（中心词），而rainy则是dependent（依赖）。该依存关系用amod标签表示，即形容词修饰语。我们可以用依存关系箭头标注语法关系： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     root</span><br><span class="line">      |</span><br><span class="line">      | +-------dobj---------+</span><br><span class="line">      | |                    |</span><br><span class="line">nsubj | |   +------det-----+ | +-----nmod------+</span><br><span class="line">+--+  | |   |              | | |               |</span><br><span class="line">|  |  | |   |      +-nmod-+| | |      +-case-+ |</span><br><span class="line">+  |  + |   +      +      || + |      +      | |</span><br><span class="line">I  prefer  the  morning   flight  through  Denver</span><br></pre></td></tr></table></figure></p>
<p>也可以表示为依存句法树（Dependency Tree Graph）：</p>
<p><img src="https://i.loli.net/2021/03/16/JtlAKsfoXhZwLjP.png" /></p>
<p>图片来源：<a href="https://zhuanlan.zhihu.com/p/66268929">CS224N笔记(五):Dependency Parsing</a></p>
<h1 id="通用依存关系">通用依存关系</h1>
<p>截至目前，UD项目的通用依存关系共有37个，这些关系的完整<a href="https://universaldependencies.org/u/dep/">列表</a>可以在这里查看并深入研究。</p>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th><strong>Nominals</strong></th>
<th><strong>Clauses</strong></th>
<th><strong>Modifier words</strong></th>
<th><strong>Function Words</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Core arguments</strong></td>
<td><a href="https://universaldependencies.org/u/dep/nsubj.html">nsubj</a> <a href="https://universaldependencies.org/u/dep/obj.html">obj</a> <a href="https://universaldependencies.org/u/dep/iobj.html">iobj</a></td>
<td><a href="https://universaldependencies.org/u/dep/csubj.html">csubj</a> <a href="https://universaldependencies.org/u/dep/ccomp.html">ccomp</a> <a href="https://universaldependencies.org/u/dep/xcomp.html">xcomp</a></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td><strong>Non-core dependents</strong></td>
<td><a href="https://universaldependencies.org/u/dep/obl.html">obl</a> <a href="https://universaldependencies.org/u/dep/vocative.html">vocative</a> <a href="https://universaldependencies.org/u/dep/expl.html">expl</a> <a href="https://universaldependencies.org/u/dep/dislocated.html">dislocated</a></td>
<td><a href="https://universaldependencies.org/u/dep/advcl.html">advcl</a></td>
<td><a href="https://universaldependencies.org/u/dep/advmod.html">advmod</a>* <a href="https://universaldependencies.org/u/dep/discourse.html">discourse</a></td>
<td><a href="https://universaldependencies.org/u/dep/aux_.html">aux</a> <a href="https://universaldependencies.org/u/dep/cop.html">cop</a> <a href="https://universaldependencies.org/u/dep/mark.html">mark</a></td>
</tr>
<tr class="odd">
<td><strong>Nominal dependents</strong></td>
<td><a href="https://universaldependencies.org/u/dep/nmod.html">nmod</a> <a href="https://universaldependencies.org/u/dep/appos.html">appos</a> <a href="https://universaldependencies.org/u/dep/nummod.html">nummod</a></td>
<td><a href="https://universaldependencies.org/u/dep/acl.html">acl</a></td>
<td><a href="https://universaldependencies.org/u/dep/amod.html">amod</a></td>
<td><a href="https://universaldependencies.org/u/dep/det.html">det</a> <a href="https://universaldependencies.org/u/dep/clf.html">clf</a> <a href="https://universaldependencies.org/u/dep/case.html">case</a></td>
</tr>
<tr class="even">
<td><strong>Coordination</strong></td>
<td><strong>MWE</strong></td>
<td><strong>Loose</strong></td>
<td><strong>Special</strong></td>
<td><strong>Other</strong></td>
</tr>
<tr class="odd">
<td><a href="https://universaldependencies.org/u/dep/conj.html">conj</a> <a href="https://universaldependencies.org/u/dep/cc.html">cc</a></td>
<td><a href="https://universaldependencies.org/u/dep/fixed.html">fixed</a> <a href="https://universaldependencies.org/u/dep/flat.html">flat</a> <a href="https://universaldependencies.org/u/dep/compound.html">compound</a></td>
<td><a href="https://universaldependencies.org/u/dep/list.html">list</a> <a href="https://universaldependencies.org/u/dep/parataxis.html">parataxis</a></td>
<td><a href="https://universaldependencies.org/u/dep/orphan.html">orphan</a> <a href="https://universaldependencies.org/u/dep/goeswith.html">goeswith</a> <a href="https://universaldependencies.org/u/dep/reparandum.html">reparandum</a></td>
<td><a href="https://universaldependencies.org/u/dep/punct.html">punct</a> <a href="https://universaldependencies.org/u/dep/root.html">root</a> <a href="https://universaldependencies.org/u/dep/dep.html">dep</a></td>
</tr>
</tbody>
</table>
<p>此外还有一些基于特定语言的依存关系。斯坦福依存分析定义了接近50个依存关系，具体的定义可参考：<a href="https://nlp.stanford.edu/software/dependencies_manual.pdf">Stanford typed dependencies manual</a>。</p>
<p>关于依存句法分析，也可以参考Daniel Jurafsky的经典NLP书籍Speech and Language Processing相关<a href="https://web.stanford.edu/~jurafsky/slp3/14.pdf">章节</a>。</p>
<span id="more"></span>
<h1 id="工具推荐">工具推荐</h1>
<h2 id="stanford-parser句法分析">Stanford Parser句法分析</h2>
<p>比较有名的工具是Stanford Parser，我们可以在<a href="http://nlp.stanford.edu:8080/corenlp/">这里</a>在线使用并进行可视化。</p>
<p>或者安装斯坦福的Python NLP软件包<a href="https://stanfordnlp.github.io/stanza/installation_usage.html">Stanza</a>，里面集成了<a href="https://stanfordnlp.github.io/stanza/depparse.html">依存关系分析</a>工具。</p>
<p>如何解决download()下载异常的问题可以参考<a href="https://blog.csdn.net/superyangtze/article/details/105252193">这里</a>。</p>
<p>我们可以进行词性标注：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> stanza</span><br><span class="line"><span class="comment"># stanza.download(&#x27;en&#x27;)</span></span><br><span class="line">nlp = stanza.Pipeline(<span class="string">&#x27;en&#x27;</span>)</span><br><span class="line">doc = nlp(<span class="string">&#x27;It took me more than two hours to translate a few pages of English.&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> sentence <span class="keyword">in</span> doc.sentences:</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> sentence.words:</span><br><span class="line">        print(word.text, word.lemma, word.pos)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">It it PRON</span></span><br><span class="line"><span class="string">took take VERB</span></span><br><span class="line"><span class="string">me I PRON</span></span><br><span class="line"><span class="string">more more ADJ</span></span><br><span class="line"><span class="string">than than ADP</span></span><br><span class="line"><span class="string">two two NUM</span></span><br><span class="line"><span class="string">hours hour NOUN</span></span><br><span class="line"><span class="string">to to PART</span></span><br><span class="line"><span class="string">translate translate VERB</span></span><br><span class="line"><span class="string">a a DET</span></span><br><span class="line"><span class="string">few few ADJ</span></span><br><span class="line"><span class="string">pages page NOUN</span></span><br><span class="line"><span class="string">of of ADP</span></span><br><span class="line"><span class="string">English English PROPN</span></span><br><span class="line"><span class="string">. . PUNCT</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>以及依存句法分析： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> stanza</span><br><span class="line"><span class="comment"># stanza.download(&#x27;en&#x27;)</span></span><br><span class="line">nlp = stanza.Pipeline(<span class="string">&#x27;en&#x27;</span>)</span><br><span class="line">doc = nlp(<span class="string">&#x27;It took me more than two hours to translate a few pages of English.&#x27;</span>)</span><br><span class="line">print(*[<span class="string">f&#x27;id: <span class="subst">&#123;word.<span class="built_in">id</span>&#125;</span>\tword: <span class="subst">&#123;word.text&#125;</span>\thead id: <span class="subst">&#123;word.head&#125;</span>\thead: <span class="subst">&#123;sent.words[word.head-<span class="number">1</span>].text <span class="keyword">if</span> word.head &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;root&quot;</span>&#125;</span>\tdeprel: <span class="subst">&#123;word.deprel&#125;</span>&#x27;</span> <span class="keyword">for</span> sent <span class="keyword">in</span> doc.sentences <span class="keyword">for</span> word <span class="keyword">in</span> sent.words], sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="built_in">id</span>: <span class="number">1</span>	word: It	head <span class="built_in">id</span>: <span class="number">2</span>	head: took	deprel: expl</span><br><span class="line"><span class="built_in">id</span>: <span class="number">2</span>	word: took	head <span class="built_in">id</span>: <span class="number">0</span>	head: root	deprel: root</span><br><span class="line"><span class="built_in">id</span>: <span class="number">3</span>	word: me	head <span class="built_in">id</span>: <span class="number">2</span>	head: took	deprel: iobj</span><br><span class="line"><span class="built_in">id</span>: <span class="number">4</span>	word: more	head <span class="built_in">id</span>: <span class="number">6</span>	head: two	deprel: advmod</span><br><span class="line"><span class="built_in">id</span>: <span class="number">5</span>	word: than	head <span class="built_in">id</span>: <span class="number">4</span>	head: more	deprel: fixed</span><br><span class="line"><span class="built_in">id</span>: <span class="number">6</span>	word: two	head <span class="built_in">id</span>: <span class="number">7</span>	head: hours	deprel: nummod</span><br><span class="line"><span class="built_in">id</span>: <span class="number">7</span>	word: hours	head <span class="built_in">id</span>: <span class="number">2</span>	head: took	deprel: obj</span><br><span class="line"><span class="built_in">id</span>: <span class="number">8</span>	word: to	head <span class="built_in">id</span>: <span class="number">9</span>	head: translate	deprel: mark</span><br><span class="line"><span class="built_in">id</span>: <span class="number">9</span>	word: translate	head <span class="built_in">id</span>: <span class="number">2</span>	head: took	deprel: csubj</span><br><span class="line"><span class="built_in">id</span>: <span class="number">10</span>	word: a	head <span class="built_in">id</span>: <span class="number">12</span>	head: pages	deprel: det</span><br><span class="line"><span class="built_in">id</span>: <span class="number">11</span>	word: few	head <span class="built_in">id</span>: <span class="number">12</span>	head: pages	deprel: amod</span><br><span class="line"><span class="built_in">id</span>: <span class="number">12</span>	word: pages	head <span class="built_in">id</span>: <span class="number">9</span>	head: translate	deprel: obj</span><br><span class="line"><span class="built_in">id</span>: <span class="number">13</span>	word: of	head <span class="built_in">id</span>: <span class="number">14</span>	head: English	deprel: case</span><br><span class="line"><span class="built_in">id</span>: <span class="number">14</span>	word: English	head <span class="built_in">id</span>: <span class="number">12</span>	head: pages	deprel: nmod</span><br><span class="line"><span class="built_in">id</span>: <span class="number">15</span>	word: .	head <span class="built_in">id</span>: <span class="number">2</span>	head: took	deprel: punct</span><br></pre></td></tr></table></figure> ## Spacy依存句法分析</p>
<p>我们也可以使用Spacy进行依存句法分析并画出句法树。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># $python -m spacy download en_core_web_sm</span></span><br><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp=spacy.load(<span class="string">&#x27;en_core_web_sm&#x27;</span>)</span><br><span class="line">text=<span class="string">&#x27;It took me more than two hours to translate a few pages of English.&#x27;</span></span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> nlp(text):</span><br><span class="line">	print(token.text,<span class="string">&#x27;=&gt;&#x27;</span>,token.dep_,<span class="string">&#x27;=&gt;&#x27;</span>,token.head.text)</span><br></pre></td></tr></table></figure>
<p>输出结果如下，对比stanza的结果，还是有明显差异，例如此处it被标记为<code>nsubj</code>，但其实这种情况下it是虚词expletive（我们都学过形式主语），不担任谓词的语义角色，因此应该标记为expl。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">It &#x3D;&gt; nsubj &#x3D;&gt; took</span><br><span class="line">took &#x3D;&gt; ROOT &#x3D;&gt; took</span><br><span class="line">me &#x3D;&gt; dative &#x3D;&gt; took</span><br><span class="line">more &#x3D;&gt; amod &#x3D;&gt; two</span><br><span class="line">than &#x3D;&gt; quantmod &#x3D;&gt; two</span><br><span class="line">two &#x3D;&gt; nummod &#x3D;&gt; hours</span><br><span class="line">hours &#x3D;&gt; dobj &#x3D;&gt; took</span><br><span class="line">to &#x3D;&gt; aux &#x3D;&gt; translate</span><br><span class="line">translate &#x3D;&gt; xcomp &#x3D;&gt; took</span><br><span class="line">a &#x3D;&gt; det &#x3D;&gt; pages</span><br><span class="line">few &#x3D;&gt; amod &#x3D;&gt; pages</span><br><span class="line">pages &#x3D;&gt; dobj &#x3D;&gt; translate</span><br><span class="line">of &#x3D;&gt; prep &#x3D;&gt; pages</span><br><span class="line">English &#x3D;&gt; pobj &#x3D;&gt; of</span><br><span class="line">. &#x3D;&gt; punct &#x3D;&gt; took</span><br></pre></td></tr></table></figure>
<p>画图的方法参考<a href="https://spacy.io/usage/visualizers">spacy可视化工具</a>，如果是在sublime text之类的编辑器内运行代码，我们需要打开浏览器地址http://localhost:5000/查看画图的结果。如果是jupyter notebook，则可以直接显示图像。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line"><span class="keyword">from</span> spacy <span class="keyword">import</span> displacy</span><br><span class="line"></span><br><span class="line">nlp = spacy.load(<span class="string">&quot;en_core_web_sm&quot;</span>)</span><br><span class="line">doc = nlp(<span class="string">&quot;It took me more than two hours to translate a few pages of English.&quot;</span>)</span><br><span class="line">displacy.serve(doc, style=<span class="string">&quot;dep&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/03/16/dInSpW2aBw1Dg4u.png" /></p>
<p>spacy中的依存关系有45个，完整的标签如下，具体的定义可以参考：<a href="https://nlp.stanford.edu/software/dependencies_manual.pdf">Stanford typed dependencies manual</a>。</p>
<table>
<thead>
<tr class="header">
<th>标签</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ROOT</code></td>
<td>root</td>
</tr>
<tr class="even">
<td><code>acl</code></td>
<td>clausal modifier of noun (adjectival clause)</td>
</tr>
<tr class="odd">
<td><code>acomp</code></td>
<td>adjectival complement</td>
</tr>
<tr class="even">
<td><code>advcl</code></td>
<td>adverbial clause modifier</td>
</tr>
<tr class="odd">
<td><code>advmod</code></td>
<td>adverbial modifier</td>
</tr>
<tr class="even">
<td><code>agent</code></td>
<td>agent</td>
</tr>
<tr class="odd">
<td><code>amod</code></td>
<td>adjectival modifier</td>
</tr>
<tr class="even">
<td><code>appos</code></td>
<td>appositional modifier</td>
</tr>
<tr class="odd">
<td><code>attr</code></td>
<td>attribute</td>
</tr>
<tr class="even">
<td><code>aux</code></td>
<td>auxiliary</td>
</tr>
<tr class="odd">
<td><code>auxpass</code></td>
<td>auxiliary (passive)</td>
</tr>
<tr class="even">
<td><code>case</code></td>
<td>case marking</td>
</tr>
<tr class="odd">
<td><code>cc</code></td>
<td>coordinating conjunction</td>
</tr>
<tr class="even">
<td><code>ccomp</code></td>
<td>clausal complement</td>
</tr>
<tr class="odd">
<td><code>compound</code></td>
<td>compound</td>
</tr>
<tr class="even">
<td><code>conj</code></td>
<td>conjunct</td>
</tr>
<tr class="odd">
<td><code>csubj</code></td>
<td>clausal subject</td>
</tr>
<tr class="even">
<td><code>csubjpass</code></td>
<td>clausal subject (passive)</td>
</tr>
<tr class="odd">
<td><code>dative</code></td>
<td>dative</td>
</tr>
<tr class="even">
<td><code>dep</code></td>
<td>unclassified dependent</td>
</tr>
<tr class="odd">
<td><code>det</code></td>
<td>determiner</td>
</tr>
<tr class="even">
<td><code>dobj</code></td>
<td>direct object</td>
</tr>
<tr class="odd">
<td><code>expl</code></td>
<td>expletive</td>
</tr>
<tr class="even">
<td><code>intj</code></td>
<td>interjection</td>
</tr>
<tr class="odd">
<td><code>mark</code></td>
<td>marker</td>
</tr>
<tr class="even">
<td><code>meta</code></td>
<td>meta modifier</td>
</tr>
<tr class="odd">
<td><code>neg</code></td>
<td>negation modifier</td>
</tr>
<tr class="even">
<td><code>nmod</code></td>
<td>modifier of nominal</td>
</tr>
<tr class="odd">
<td><code>npadvmod</code></td>
<td>noun phrase as adverbial modifier</td>
</tr>
<tr class="even">
<td><code>nsubj</code></td>
<td>nominal subject</td>
</tr>
<tr class="odd">
<td><code>nsubjpass</code></td>
<td>nominal subject (passive)</td>
</tr>
<tr class="even">
<td><code>nummod</code></td>
<td>numeric modifier</td>
</tr>
<tr class="odd">
<td><code>oprd</code></td>
<td>object predicate</td>
</tr>
<tr class="even">
<td><code>parataxis</code></td>
<td>parataxis</td>
</tr>
<tr class="odd">
<td><code>pcomp</code></td>
<td>complement of preposition</td>
</tr>
<tr class="even">
<td><code>pobj</code></td>
<td>object of preposition</td>
</tr>
<tr class="odd">
<td><code>poss</code></td>
<td>possession modifier</td>
</tr>
<tr class="even">
<td><code>preconj</code></td>
<td>pre-correlative conjunction</td>
</tr>
<tr class="odd">
<td><code>predet</code></td>
<td>predeterminer</td>
</tr>
<tr class="even">
<td><code>prep</code></td>
<td>prepositional modifier</td>
</tr>
<tr class="odd">
<td><code>prt</code></td>
<td>particle</td>
</tr>
<tr class="even">
<td><code>punct</code></td>
<td>punctuation</td>
</tr>
<tr class="odd">
<td><code>quantmod</code></td>
<td>modifier of quantifier</td>
</tr>
<tr class="even">
<td><code>relcl</code></td>
<td>relative clause modifier</td>
</tr>
<tr class="odd">
<td><code>xcomp</code></td>
<td>open clausal complement</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>自然语言处理</category>
        <category>依存分析</category>
      </categories>
      <tags>
        <tag>nlp</tag>
        <tag>dependency</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式进阶</title>
    <url>/regex-1/</url>
    <content><![CDATA[<p>至此，我们已经建立了正则表达式的思维框架（参见「<a href="http://mp.weixin.qq.com/s?__biz=MzIzMDY0NDQ1Ng==&amp;mid=2247484919&amp;idx=1&amp;sn=7309a9bf1be78ea3250838724ebaa81c&amp;chksm=e8b10a70dfc683666f6d87e6fda6f51863dbaf565ac522b6d01d80059c01a821af70bc279438&amp;scene=21#wechat_redirect">正则表达式入门</a>」），以及如何用python中的re模块编译正则表达式来匹配文本（参见「<a href="https://mp.weixin.qq.com/s/ibNb0rOSnBr4YC0PzCyIBA">Python实操篇</a>」）。尽管此时我们已经可以流畅地编写和使用它，但我们需要一些进阶知识，让我们的正则表达式更准确和精练。本文使用的语言依然是python。 <span id="more"></span></p>
<p><strong>全文概览：</strong></p>
<p>1.分组与捕获：<code>MatchObject.group()</code>的奥秘</p>
<p>2.四种类型的环视：匹配位置，而非匹配文本</p>
<p>3.贪婪与非贪婪：匹配优先 VS 忽略优先</p>
<h1 id="分组与捕获">分组与捕获</h1>
<p>在「<a href="https://mp.weixin.qq.com/s/ibNb0rOSnBr4YC0PzCyIBA">Python实操篇</a>」我们讲到<code>MatchObject</code>的方法<code>group()</code>可以返回匹配的整个字符串，但这并不全面。本节，我们将谈谈括号的一个关键功能：捕获（capturing）。</p>
<p><strong>捕获</strong>就是用括号提取文本以便后续访问，我们可以把这个过程想象成“闰土捕鸟”，把每个括号里的鸟儿都抓起来放进“笼子”。</p>
<p>而捕获进所有“笼子”里的内容，正是通过<code>MatchObject.groups()</code>访问。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.search(<span class="string">r&quot;(\w+) (\w+)&quot;</span>, <span class="string">&quot;John Smith&quot;</span>).groups()</span><br><span class="line"><span class="comment"># 输出：(&#x27;John&#x27;, &#x27;Smith&#x27;)</span></span><br></pre></td></tr></table></figure>
<p>我们可以通过索引来访问每个“笼子”，<code>group(0)</code>返回整个正则表达式匹配的文本，相当于编号为0的隐式捕获，而<code>group(1)</code>、<code>group(2)</code>则按顺序返回显式捕获分组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">m = re.search(<span class="string">r&quot;(\w+) (\w+)&quot;</span>, <span class="string">&quot;John Smith&quot;</span>)</span><br><span class="line">m.group(<span class="number">0</span>) <span class="comment"># 输出：&#x27;John Smith&#x27;</span></span><br><span class="line">m.group(<span class="number">1</span>)  <span class="comment"># 输出：&#x27;John&#x27;</span></span><br><span class="line">m.group(<span class="number">2</span>)  <span class="comment"># 输出：&#x27;Smith&#x27;</span></span><br></pre></td></tr></table></figure>
<p>你可能会想到「<a href="http://mp.weixin.qq.com/s?__biz=MzIzMDY0NDQ1Ng==&amp;mid=2247484919&amp;idx=1&amp;sn=7309a9bf1be78ea3250838724ebaa81c&amp;chksm=e8b10a70dfc683666f6d87e6fda6f51863dbaf565ac522b6d01d80059c01a821af70bc279438&amp;scene=21#wechat_redirect">入门篇</a>」讲过的<strong>反向引用</strong>，在python中我们依然可以使用序号<code>\1</code>、<code>\2</code>来引用捕获的组别。下面这个例子将“数字-字母”组成的产品ID进行替换，变成了“字母-数字”的形式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&quot;(\d+)-(\w+)&quot;</span>)</span><br><span class="line">pattern.sub(<span class="string">r&quot;\2-\1&quot;</span>, <span class="string">&quot;1-a\n20-baer\n34-afcr&quot;</span>)</span><br><span class="line"><span class="comment"># 输出：&#x27;a-1\nbaer-20\nafcr-34&#x27;</span></span><br></pre></td></tr></table></figure>
<p>我们也可以给每个“笼子”取上名字，即<strong>命名捕获</strong>，在python正则表达式中表示为<code>(?P&lt;name&gt;pattern)</code>，依然是通过<code>group()</code>访问单个“笼子”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&quot;(?P&lt;first&gt;\w+) (?P&lt;last&gt;\w+)&quot;</span>)</span><br><span class="line">match = pattern.search(<span class="string">&quot;John Smith&quot;</span>)</span><br><span class="line">match.group(<span class="string">&quot;first&quot;</span>) <span class="comment"># 输出：&#x27;John&#x27;</span></span><br><span class="line">match.group(<span class="string">&quot;last&quot;</span>) <span class="comment"># 输出：&#x27;Smith&#x27;</span></span><br></pre></td></tr></table></figure>
<p>需要注意，在<code>sub()</code>替换操作中，如果用名称来引用组别，我们需要写成<code>\g&lt;name&gt;</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&quot;(?P&lt;country&gt;\d+)-(?P&lt;id&gt;\w+)&quot;</span>)</span><br><span class="line">pattern.sub(<span class="string">r&quot;\g&lt;id&gt;-\g&lt;country&gt;&quot;</span>, <span class="string">&quot;1-a\n20-baer\n34-afcr&quot;</span>)</span><br><span class="line"><span class="comment"># 输出：&#x27;a-1\nbaer-20\nafcr-34&#x27;</span></span><br></pre></td></tr></table></figure>
<p>当然，很多时候我们使用括号不是为了捕获，而仅仅是为了<strong>分组</strong>，即用于构建子表达式、多选结构或者量词作用的对象。此时，我们可以使用<strong>非捕获型括号</strong><code>(?:)</code>，告诉正则引擎，不需要提取括号内的任何信息。非捕获型括号能够提高效率、节约内存，不浪费咱们的“笼子”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.search(<span class="string">r&quot;gr(a|e)y&quot;</span>, <span class="string">&quot;gray&quot;</span>).groups()</span><br><span class="line"><span class="comment"># 输出：(&#x27;a&#x27;,)</span></span><br><span class="line">re.search(<span class="string">r&quot;gr(?:a|e)y&quot;</span>, <span class="string">&quot;gray&quot;</span>).groups()</span><br><span class="line"><span class="comment"># 输出：()</span></span><br></pre></td></tr></table></figure>
<h1 id="四种类型的环视">四种类型的环视</h1>
<p><strong>环视</strong>（Look Around）是正则表达式最强大的技术之一。我们可以把环视想象成前视镜和后视镜，<strong>顺序环视</strong>就是向前看（从左到右），<strong>逆序环视</strong>就是向后看（从右到左）。通过左右环视，我们进行“闰土捕鸟”的位置会更精确，确保匹配内容的上下文满足特定要求。</p>
<p>以下是四种类型的环视：</p>
<table>
<thead>
<tr class="header">
<th>类型</th>
<th>正则表达式</th>
<th>匹配成功的条件</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>肯定顺序环视</td>
<td>(?=……)</td>
<td>子表达式能够匹配右侧文本</td>
</tr>
<tr class="even">
<td>否定顺序环视</td>
<td>(?!……)</td>
<td>子表达式不能匹配右侧文本</td>
</tr>
<tr class="odd">
<td>肯定逆序环视</td>
<td>(?&lt;=……)</td>
<td>子表达式能够匹配左侧文本</td>
</tr>
<tr class="even">
<td>否定逆序环视</td>
<td>(?&lt;!……)</td>
<td>子表达式不能匹配左侧文本</td>
</tr>
</tbody>
</table>
<p>我们要注意，环视相当于作用于匹配位置的附加条件、不占用任何字符。因此它和分界符类似，是一种<strong>零宽度断言</strong>（zero-width assertions）。我们拿肯定顺序环视举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;(?=fox)&#x27;</span>)</span><br><span class="line">result = pattern.search(<span class="string">&quot;The quick brown fox jumps over the lazy dog&quot;</span>)</span><br><span class="line">result.span()</span><br><span class="line"><span class="comment">#输出 (16, 16)</span></span><br></pre></td></tr></table></figure>
<p>我们发现，表达式<code>(?=fox)</code>只匹配fox之前的位置，也就是索引16。</p>
<p><img src="C:\Users\13607\AppData\Roaming\Typora\typora-user-images\image-20210218222948086.png" alt="image-20210218222948086" style="zoom: 33%;" /></p>
<p>环视的作用不可小觑，我们可以精准定位，并剔除多余字符，保留更加干净、准确的匹配文本。下面的例子定位<code>&lt;p&gt;</code>标签的同时，只匹配标签里的内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;(?&lt;=&lt;p&gt;)[^&lt;]+(?=&lt;p&gt;)&#x27;</span>)</span><br><span class="line">pattern.search(<span class="string">&quot;&lt;p&gt;test&lt;p&gt;&quot;</span>).group(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 输出：&#x27;test&#x27;</span></span><br></pre></td></tr></table></figure>
<p>环视的另一典型应用就是将文本变成逗号分隔的货币形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\d&#123;1,3&#125;(?=(\d&#123;3&#125;)+(?!\d))&#x27;</span>)</span><br><span class="line">pattern.sub(<span class="string">r&#x27;\g&lt;0&gt;,&#x27;</span>, <span class="string">&quot;123456789&quot;</span>)</span><br><span class="line"><span class="comment"># 输出：&#x27;123,456,789&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="贪婪与非贪婪">贪婪与非贪婪</h1>
<p>在「<a href="http://mp.weixin.qq.com/s?__biz=MzIzMDY0NDQ1Ng==&amp;mid=2247484919&amp;idx=1&amp;sn=7309a9bf1be78ea3250838724ebaa81c&amp;chksm=e8b10a70dfc683666f6d87e6fda6f51863dbaf565ac522b6d01d80059c01a821af70bc279438&amp;scene=21#wechat_redirect">入门篇</a>」中，我们接触了量词，但并未讲到贪婪与非贪婪的区别。</p>
<p>在python的re模块中，量词默认为<strong>贪婪模式</strong>：尽可能多地匹配更长的字符串。这就是为什么，<code>.*</code>通常会匹配到一行文本的末尾。如果要采用<strong>非贪婪模式</strong>，我们可以在量词后添加一个额外的问号，例如<code>??</code>、<code>*?</code>或<code>+?</code>，使得匹配的长度最小。这两种模式又称为<strong>匹配优先</strong>和<strong>忽略优先</strong>。</p>
<ul>
<li><p>贪婪量词（Greedy quantifiers）：<code>?</code>, <code>*</code>, <code>+</code>, <code>&#123;num,num&#125;</code></p></li>
<li><p>非贪婪/懒惰量词（Lazy quantifiers）：<code>??</code>, <code>*?</code>, <code>+?</code> , <code>&#123;num,num&#125;?</code></p></li>
</ul>
<p>比如，如果要匹配引号内的内容，会得到下面的结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;The name &quot;McDonald\&#x27;s&quot; ! is said &quot;makudonarudo&quot;in Japanese.&#x27;</span></span><br><span class="line">re.search(<span class="string">r&#x27;&quot;.*&quot;&#x27;</span>, s).group()</span><br><span class="line"><span class="comment"># 输出：&#x27;&quot;McDonald\&#x27;s&quot; is said &quot;makudonarudo&quot;&#x27;</span></span><br><span class="line">re.search(<span class="string">r&#x27;&quot;.*?&quot;&#x27;</span>, s).group()</span><br><span class="line"><span class="comment"># 输出：&#x27;&quot;McDonald\&#x27;s&quot;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>事实上，还有第三种量词，但目前python并不支持：</p>
<ul>
<li>占有量词（Possessive quantifiers）：<code>?+</code>, <code>*+</code>, <code>++</code>, <code>&#123;num,num&#125;+</code></li>
</ul>
<p>占有量词与贪婪量词类似，只是它们从不会交还已经匹配的字符。当然，我们也可以用固化分组<code>(?&gt;...)</code>来代替，比如<code>!.++</code>其实等同于<code>(?&gt;!.+)</code>。然而，固化分组在python中同样不被支持，所以此处不过多讨论。</p>
<p>以上です！</p>
<p>整理完python正则表达式的进阶知识，相信你已经能得心应手解决很多问题。但是，要真正打造高效、规范、美妙的正则表达式，我们仍需要了解正则引擎的原理，以及一些平衡法则、以及测试和优化的技巧，我们下篇再谈！</p>
]]></content>
      <categories>
        <category>自然语言处理</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title>纯文本文件的处理</title>
    <url>/txt/</url>
    <content><![CDATA[<h1 id="正则表达式">正则表达式</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">file_path = <span class="string">r&#x27;D:\books\Psychology_of_Language.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    txt_string = f.read()</span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;第一 初见.*第二 再见&#x27;</span>, re.DOTALL)</span><br><span class="line">cha1 = re.search(pattern, txt_string).group()</span><br><span class="line">print(re.findall(<span class="string">r&#x27;蓝色&#x27;</span>, cha1))</span><br><span class="line"></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;第一 初见[^蓝色]*(蓝色)*.*第二 再见&#x27;</span>, re.DOTALL)</span><br><span class="line">match = re.search(pattern, txt_string)</span><br><span class="line"><span class="keyword">if</span> match:</span><br><span class="line">    print(match.groups())</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="获取文章目录">获取文章目录</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">file_path = <span class="string">r&#x27;D:\project\hexo-final\source\_posts&#x27;</span></span><br><span class="line"><span class="comment"># 这里要修改</span></span><br><span class="line"><span class="comment"># weblink = &#x27;https://github.com/MissFreak/writings/blob/main/&#x27;</span></span><br><span class="line">weblink = <span class="string">&#x27;http://nlpcourse.cn/&#x27;</span></span><br><span class="line">lst = os.listdir(file_path)</span><br><span class="line">post_list = []</span><br><span class="line"><span class="comment"># 这里要修改</span></span><br><span class="line">md_name = <span class="string">&#x27;all-posts.md&#x27;</span></span><br><span class="line"><span class="comment"># md_name = &#x27;README.md&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># obtain the titles and categories of all posts</span></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> lst:</span><br><span class="line">	<span class="comment"># make sure it is a markdown file</span></span><br><span class="line">	<span class="keyword">if</span> filename[-<span class="number">3</span>:] == <span class="string">&#x27;.md&#x27;</span>:</span><br><span class="line">		<span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(file_path, filename), encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">			s = f.read()</span><br><span class="line"></span><br><span class="line">		<span class="comment"># create a dict that stores attributes: title and category_1 and category_2</span></span><br><span class="line">		post_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment"># get the title</span></span><br><span class="line">		match_title = re.search(<span class="string">r&#x27;(?&lt;=title: ).*(?=\n)&#x27;</span>, s)</span><br><span class="line">		<span class="keyword">if</span> match_title:</span><br><span class="line">			title = match_title.group().strip(<span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			title = filename</span><br><span class="line"></span><br><span class="line">		<span class="comment"># convert into linked title</span></span><br><span class="line">        <span class="comment"># 这里要修改</span></span><br><span class="line">		<span class="comment"># linked_title = &#x27;[&#123;&#125;](&#123;&#125;&#123;&#125;)&#x27;.format(title, weblink, filename)</span></span><br><span class="line">		linked_title = <span class="string">&#x27;[&#123;&#125;](&#123;&#125;&#123;&#125;)&#x27;</span>.<span class="built_in">format</span>(title, weblink, filename[:-<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">		<span class="comment"># get the categories</span></span><br><span class="line">		match_categories = re.search(<span class="string">r&#x27;categories:\n- (.*)\n- (.*)\n&#x27;</span>, s)</span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			category_1 = match_categories.group(<span class="number">1</span>)</span><br><span class="line">			category_2 = match_categories.group(<span class="number">2</span>)</span><br><span class="line">		<span class="keyword">except</span>:</span><br><span class="line">			category_1 = <span class="string">&#x27;未分类&#x27;</span></span><br><span class="line">			category_2 = <span class="string">&#x27;未分类&#x27;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment"># save into a list</span></span><br><span class="line">		post_dict[<span class="string">&#x27;title&#x27;</span>] = linked_title</span><br><span class="line">		post_dict[<span class="string">&#x27;category_1&#x27;</span>] = category_1</span><br><span class="line">		post_dict[<span class="string">&#x27;category_2&#x27;</span>] = category_2</span><br><span class="line">		post_list.append(post_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sort and group by the first category</span></span><br><span class="line">get_first_category = <span class="keyword">lambda</span> dct: dct.get(<span class="string">&#x27;category_1&#x27;</span>)</span><br><span class="line">group_1 = itertools.groupby(<span class="built_in">sorted</span>(post_list, key=get_first_category), get_first_category)</span><br><span class="line">num_post = <span class="built_in">len</span>(post_list)</span><br><span class="line"></span><br><span class="line">content = <span class="string">&#x27;---\ntitle: 所有文章目录\n---\n&lt;center&gt;目前共有&#123;&#125;篇文章：&lt;/center&gt;\n&lt;!-- more --&gt;\n\n&#x27;</span>.<span class="built_in">format</span>(num_post)</span><br><span class="line"><span class="keyword">for</span> k1,v1 <span class="keyword">in</span> group_1:</span><br><span class="line">	<span class="comment"># add the first category into content</span></span><br><span class="line">	content += (<span class="string">&#x27;# &#x27;</span>+k1+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">	<span class="comment"># sort and group by the first category</span></span><br><span class="line">	get_second_category = <span class="keyword">lambda</span> dct: dct.get(<span class="string">&#x27;category_2&#x27;</span>)</span><br><span class="line">	group_2 = itertools.groupby(<span class="built_in">sorted</span>(v1, key=get_second_category), get_second_category)</span><br><span class="line">	<span class="keyword">for</span> k2,v2 <span class="keyword">in</span> group_2:</span><br><span class="line">		<span class="comment"># add the second category into content</span></span><br><span class="line">		<span class="keyword">if</span> k2 != <span class="string">&#x27;未分类&#x27;</span>:</span><br><span class="line">			content += (<span class="string">&#x27;- _&#x27;</span>+k2+<span class="string">&#x27;_\n&#x27;</span>)</span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> v2:</span><br><span class="line">				<span class="comment"># add the title into content</span></span><br><span class="line">				content += (<span class="string">&#x27;\t- &#x27;</span>+i[<span class="string">&#x27;title&#x27;</span>]+<span class="string">&#x27;\n\n&#x27;</span>)</span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			<span class="keyword">for</span> i <span class="keyword">in</span> v2:</span><br><span class="line">				<span class="comment"># add the title into content</span></span><br><span class="line">				content += (<span class="string">&#x27;- &#x27;</span>+i[<span class="string">&#x27;title&#x27;</span>]+<span class="string">&#x27;\n\n&#x27;</span>)</span><br><span class="line">print(content)</span><br><span class="line"><span class="comment"># write the content into md file</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(file_path, md_name), <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	f.write(content)</span><br></pre></td></tr></table></figure>
<h1 id="分离章节">分离章节</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">file_path = <span class="string">r&#x27;D:\books\Psychology_of_Language.txt&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    txt_string = f.read()</span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">r&#x27;\ng\n&#x27;</span>)</span><br><span class="line">chapters = pattern.split(txt_string)[<span class="number">6</span>:]</span><br><span class="line"></span><br><span class="line">cha8 = chapters[<span class="number">7</span>]</span><br><span class="line">cha8 = re.sub(<span class="string">r&#x27;\nn\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>, cha8)</span><br><span class="line">cha8 = re.sub(<span class="string">r&#x27;\n&#123;2,&#125;&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>, cha8)</span><br><span class="line">cha8 = re.sub(<span class="string">r&#x27;-&#x27;</span>, <span class="string">&#x27;&#x27;</span>, cha8)</span><br><span class="line"><span class="comment"># print(repr(cha8))</span></span><br><span class="line">print(cha8)</span><br></pre></td></tr></table></figure>
<h1 id="去除字符">去除字符</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ss = <span class="string">&#x27;我的电话是18827038663，也是微信号，\n 请加入，谢谢\n\n\n&#x27;</span></span><br><span class="line">print(ss.strip(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">ss = <span class="string">&#x27;我的电话是18827038663，也是微信号，\n 请加入，谢谢\n\n\n&#x27;</span></span><br><span class="line">print(ss.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line">ss = <span class="string">&#x27;我的电话是18827038663，也是微信号，请加入，谢谢啦啦嗯&#x27;</span></span><br><span class="line">print(ss.strip(<span class="string">&#x27;嗯啦&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h1 id="表格pytablewriter">表格：<a href="https://github.com/thombashi/pytablewriter/">pytablewriter</a></h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MarkdownTableWriter, ExcelXlsxTableWriter, UnicodeTableWriter, JavaScriptTableWriter, JsonTableWriter, HtmlTableWriter</span><br></pre></td></tr></table></figure>
<p>先获得matrix：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;tempo.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	s = f.read()</span><br><span class="line">matrix = [i.split(<span class="string">&#x27;: &#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> s.split(<span class="string">&#x27;\n&#x27;</span>)] <span class="comment"># 行分隔符和列分隔符</span></span><br><span class="line">print(matrix)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;tempo2.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	s = f.read()</span><br><span class="line">matrix = [i.split(<span class="string">&#x27; &#x27;</span>, <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> s.split(<span class="string">&#x27;\n&#x27;</span>)] <span class="comment"># split on first occurrence</span></span><br><span class="line">print(matrix)</span><br></pre></td></tr></table></figure>
<p>然后生成相应的表格：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytablewriter</span><br><span class="line">writer = pytablewriter.MarkdownTableWriter()</span><br><span class="line">writer.value_matrix = matrix</span><br><span class="line">writer.write_table()</span><br></pre></td></tr></table></figure>
<h2 id="markdown表格">markdown表格</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># s = spacy.explain(&#x27;``&#x27;)</span></span><br><span class="line"><span class="comment"># print(repr(s))</span></span><br><span class="line">lst1 = <span class="string">&#x27;`$`, `&#x27;</span><span class="string">&#x27;`, `,`, `-LRB-`, `-RRB-`, `.`, `:`, `ADD`, `AFX`, `CC`, `CD`, `DT`, `EX`, `FW`, `HYPH`, `IN`, `JJ`, `JJR`, `JJS`, `LS`, `MD`, `NFP`, `NN`, `NNP`, `NNPS`, `NNS`, `PDT`, `POS`, `PRP`, `PRP$`, `RB`, `RBR`, `RBS`, `RP`, `SYM`, `TO`, `UH`, `VB`, `VBD`, `VBG`, `VBN`, `VBP`, `VBZ`, `WDT`, `WP`, `WP$`, `WRB`, `XX`&#x27;</span>.split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">lst2 = [spacy.explain(i.strip(<span class="string">&#x27; `&#x27;</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> lst1]</span><br><span class="line"><span class="comment"># print(lst2)</span></span><br><span class="line"></span><br><span class="line">matrix = np.column_stack((lst1, lst2)).tolist()</span><br><span class="line"><span class="comment"># print(type(matrix))</span></span><br><span class="line"><span class="comment"># print(matrix)</span></span><br><span class="line"><span class="keyword">import</span> pytablewriter</span><br><span class="line">writer = pytablewriter.MarkdownTableWriter()</span><br><span class="line">writer.value_matrix = matrix</span><br><span class="line">writer.write_table()</span><br></pre></td></tr></table></figure>
<h2 id="csv">csv</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytablewriter</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    writer = pytablewriter.CsvTableWriter()</span><br><span class="line">    writer.headers = [<span class="string">&quot;int&quot;</span>, <span class="string">&quot;float&quot;</span>, <span class="string">&quot;str&quot;</span>, <span class="string">&quot;bool&quot;</span>, <span class="string">&quot;mix&quot;</span>, <span class="string">&quot;time&quot;</span>]</span><br><span class="line">    writer.value_matrix = [</span><br><span class="line">        [<span class="number">0</span>,   <span class="number">0.1</span>,      <span class="string">&quot;hoge&quot;</span>, <span class="literal">True</span>,   <span class="number">0</span>,      <span class="string">&quot;2017-01-01 03:04:05+0900&quot;</span>],</span><br><span class="line">        [<span class="number">2</span>,   <span class="string">&quot;-2.23&quot;</span>,  <span class="string">&quot;foo&quot;</span>,  <span class="literal">False</span>,  <span class="literal">None</span>,   <span class="string">&quot;2017-12-23 45:01:23+0900&quot;</span>],</span><br><span class="line">        [<span class="number">3</span>,   <span class="number">0</span>,        <span class="string">&quot;bar&quot;</span>,  <span class="string">&quot;true&quot;</span>,  <span class="string">&quot;inf&quot;</span>, <span class="string">&quot;2017-03-03 33:44:55+0900&quot;</span>],</span><br><span class="line">        [-<span class="number">10</span>, -<span class="number">9.9</span>,     <span class="string">&quot;&quot;</span>,     <span class="string">&quot;FALSE&quot;</span>, <span class="string">&quot;nan&quot;</span>, <span class="string">&quot;2017-01-01 00:00:00+0900&quot;</span>],</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    writer.write_table()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h2 id="其他格式">其他格式</h2>
<p><a href="https://pytablewriter.readthedocs.io/en/latest/pages/examples/table_format/text/json.html">JSON</a></p>
<p><a href="https://pytablewriter.readthedocs.io/en/latest/pages/examples/table_format/text/html.html">HTML</a></p>
]]></content>
      <categories>
        <category>代码</category>
        <category>文本处理</category>
      </categories>
      <tags>
        <tag>txt</tag>
      </tags>
  </entry>
  <entry>
    <title>好用的API集锦</title>
    <url>/wiki-api/</url>
    <content><![CDATA[<h1 id="wikipedia-python库">Wikipedia Python库</h1>
<p><strong>Wikipedia</strong>是一个Python库，可轻松访问和解析Wikipedia中的数据，搜索Wikipedia、获取文章摘要、从页面获取链接和图像等数据等等。Wikipedia封装了<a href="https://www.mediawiki.org/wiki/API">MediaWiki API，</a>因此您可以专注于使用Wikipedia数据，而不是获取数据。 <span id="more"></span></p>
]]></content>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在curl和python中使用API</title>
    <url>/flask-api-3/</url>
    <content><![CDATA[<p>除了自己构建API，我们也可能需要使用其他网站提供的API。 <span id="more"></span></p>
<h1 id="在curl中使用api">在curl中使用API</h1>
<p>我们以学术检索网站<a href="https://api.semanticscholar.org/">semantic scholar</a>为例，查找某论文的信息，并保存为JSON文件<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl https:&#x2F;&#x2F;api.semanticscholar.org&#x2F;v1&#x2F;paper&#x2F;10.1038&#x2F;nrn3241 &gt; paper1.json</span><br></pre></td></tr></table></figure>
<p>但此时的json数据结构并不整洁，我们用python格式化json字符串并保存在paper2.json<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m json.tool paper1.json paper2.json</span><br></pre></td></tr></table></figure>
<p>或者一步到位<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl https:&#x2F;&#x2F;api.semanticscholar.org&#x2F;v1&#x2F;paper&#x2F;10.1038&#x2F;nrn3241 | python -mjson.tool &gt; paper3.json</span><br></pre></td></tr></table></figure>
<p>如果仅仅是想显示为Pretty Print打印出来，把后面的filename.json去掉即可。</p>
<h1 id="用python获取api数据">用python获取API数据</h1>
<p>依旧是这个例子，我们将返回的数据转成字典格式<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">&quot;https://api.semanticscholar.org/v1/paper/10.1038/nrn3241&quot;</span>)</span><br><span class="line">response_dic = response.json() <span class="comment"># if the result was written in JSON format, if not it raises an error</span></span><br></pre></td></tr></table></figure>
<p>更多requests相关参考<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a>。</p>
<p><strong>参考文献：</strong></p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><a href="https://www.ruanyifeng.com/blog/2019/09/curl-reference.html">curl 的用法指南</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><a href="https://docs.python.org/3/library/json.html">python json官方文档</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p><a href="https://skorks.com/2013/04/the-best-way-to-pretty-print-json-on-the-command-line/">在命令行上漂亮地打印JSON的最佳方法</a><a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p><a href="https://jzchangmark.wordpress.com/2016/06/12/%E9%80%8F%E9%81%8E-curl%E3%80%81python%E3%80%81postman-%E4%BE%86-request-api/">透过curl、Python、Postman 来Request API</a><a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p><a href="https://www.w3schools.com/python/ref_requests_response.asp">python请求</a><a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>网站开发</category>
        <category>flask</category>
      </categories>
      <tags>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title>一个人开发信息检索与抽取网站的全过程</title>
    <url>/flask-web/</url>
    <content><![CDATA[<h1 id="我的网站开发学习">我的网站开发学习</h1>
<p>我不会使用css或js文件，因为我只专注于python后端开发，前端基本都省去，只用bootstrap，但是要精通bootstrap哟！</p>
<p>计划：</p>
<ol type="1">
<li>完成检索功能，包括错误检测。检索成语、句子、词语等等。</li>
<li>其他小插件的完善</li>
<li>重点是毕业论文</li>
</ol>
<span id="more"></span>
<h1 id="搜索框">搜索框</h1>
<p>首先我们把boostrap加入html页面，直接使用<a href="https://www.bootstrapcdn.com/">BootstrapCDN</a>跳过下载，将Bootstrap编译的CSS和JS的缓存版本交付给我们的项目。我们使用最简单的主题即可，也可以使用其他主题（比如<a href="https://bootswatch.com/minty/">minty</a>）。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;</span> <span class="attr">integrity</span>=<span class="string">&quot;sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;form my-2 my-lg-0&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-control mr-sm-2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Search&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-secondary my-2 my-sm-0&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Search<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js&quot;</span> <span class="attr">integrity</span>=<span class="string">&quot;sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;idiom.json&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> read_file:</span><br><span class="line">    idiom_list = json.load(read_file)</span><br><span class="line"></span><br><span class="line">idiom_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> idiom <span class="keyword">in</span> idiom_list:</span><br><span class="line">    idiom_dict[idiom[<span class="string">&#x27;word&#x27;</span>]] = idiom</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;idiom_dict.json&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> write_file:</span><br><span class="line">    json.dump(idiom_dict, write_file)</span><br><span class="line">print(<span class="string">&#x27;成功将原列表转换为key为成语的字典！&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>查看源代码，</p>
<p>参考：</p>
<p>https://www.bootdey.com/snippets/view/Search-Results#html</p>
<p><a href="https://blog.csdn.net/star_xing123/article/details/101271925">百度搜索框</a></p>
<p><a href="https://www.html.cn/qa/css3/12786.html">怎么在HTML中加入css样式？ - html中文网</a></p>
<p><a href="https://getbootstrap.com/docs/4.3/getting-started/introduction/">Bootstrap Introduction</a></p>
<p><a href="https://bootswatch.com/">Free themes for Bootstrap</a></p>
]]></content>
      <categories>
        <category>网站开发</category>
        <category>flask</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客Next主题搭建全过程</title>
    <url>/hexo-next/</url>
    <content><![CDATA[<p>经过三次不明觉厉的error崩盘导致我重新初始化博客（不知道哪里出错所以只有推倒重来），2021年3月18日博客终于配置完毕。在此记录全过程。最后一次配置，我只修改了三个文件：_config.yml和next/_config.yml以及custom_file_path（当然还有css/images和source）。其中custom_file_path设置为styles.styl，用于<strong>修改文章内链接文本样式</strong>、<strong>文章内单行代码的样式设置</strong>等等，需要在custom_file_path中加入这个地址。我把这些文件备份在github地址：_config.yml，next/_config.yml，next/source/css/images和source（source中有styles.styl和我写的文章）。 <span id="more"></span></p>
<h1 id="博客的初始化">博客的初始化</h1>
<p>关于怎么部署参考：https://zhuanlan.zhihu.com/p/26625249</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd hexo-final</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo init</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
<p>完成以上步骤后，我们看到目前的插件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-- hexo-generator-archive@1.0.0</span><br><span class="line">+-- hexo-generator-category@1.0.0</span><br><span class="line">+-- hexo-generator-index@2.0.0</span><br><span class="line">+-- hexo-generator-tag@1.0.0</span><br><span class="line">+-- hexo-renderer-ejs@1.0.0</span><br><span class="line">+-- hexo-renderer-marked@4.0.0</span><br><span class="line">+-- hexo-renderer-stylus@2.0.1</span><br><span class="line">+-- hexo-server@2.0.0</span><br><span class="line">+-- hexo-theme-landscape@0.0.3</span><br><span class="line">&#96;-- hexo@5.4.0</span><br></pre></td></tr></table></figure>
<p>我们需要安装其他插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-- hexo-browsersync@0.3.0</span><br><span class="line">+-- hexo-deployer-git@3.0</span><br><span class="line">+-- hexo-generator-index-pin-top@0.2.2</span><br><span class="line">+-- hexo-generator-searchdb@1.3.3</span><br><span class="line">+-- hexo-related-popular-posts@5.0.1</span><br><span class="line">+-- hexo-renderer-pandoc@0.3.0</span><br><span class="line">+-- hexo-symbols-count-time@0.7.1</span><br></pre></td></tr></table></figure>
<p>安装方式： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br><span class="line">npm install 插件 --save</span><br></pre></td></tr></table></figure> 安装完毕后，我们把_config.yml和next/_config.yml以及css/images和source中的文件（注意有_data/styles.styl）复制粘贴过来。</p>
<h2 id="网上的教程">网上的教程</h2>
<p>图片操作： https://davidwells.io/snippets/how-to-align-images-in-markdown https://www.w3schools.com/html/html_images.asp</p>
<p>其他美化： https://huangpiao.tech/2019/01/24/Hexo%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96%E4%B9%8BNext%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96/</p>
<p>Markdown进阶：</p>
<p>https://blog.csdn.net/thither_shore/article/details/52181464</p>
<p>https://unnamed42.github.io/2015-12-02-Markdown%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F.html</p>
<p>https://blog.csdn.net/m0_37925202/article/details/80461714</p>
<p>Markdown使用html https://www.wuchenxu.com/2015/12/30/Markdown-html-compare/</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>《自然语言处理综论》第17章-信息抽取（上）</title>
    <url>/information-retrieval-1/</url>
    <content><![CDATA[<center>
<i>原文链接：https://web.stanford.edu/~jurafsky/slp3/17.pdf</i> <br> <i>译者：鸽鸽（自己学习使用，非商业用途）</i>
</center>
<hr />
<blockquote>
<p><em>I am the very model of a modern Major-General,</em> <em>I’ve information vegetable, animal, and mineral,</em> <em>I know the kings of England, and I quote the fights historical</em> <em>From Marathon to Waterloo, in order categorical...</em></p>
<p>Gilbert and Sullivan, Pirates of Penzance</p>
</blockquote>
<h1 id="关系提取">17.1 关系提取</h1>
<p>假设我们已经检测到了样本文本中的命名实体（也许使用了第8章的技术），并想识别出检测到的实体之间的关系：</p>
<blockquote>
<p>以高油价为由，[ORG联合航空公司]表示，[时间周五]它已将飞往一些同样由低成本航空公司服务的城市的航班的票价每往返提高了[MONEY 6美元]。发言人[per蒂姆-瓦格纳]表示，[ORG美国航空]是[ORG AMR Corp.]的一个单位，立即配合这一举措。ORG美联航]，[ORG UAL Corp.]的一个单位，说增加生效[时间周四]，适用于它与折扣航空公司竞争的大多数航线，如[LOC芝加哥]到[LOC达拉斯]和[LOC丹佛]到[LOC旧金山]。<em>(机翻结果)</em></p>
</blockquote>
<p><img src="https://i.loli.net/2021/03/18/senloyDcQAGipId.png" width="700"/></p>
<span id="more"></span>
<p>例如，这段文本告诉我们，Tim Wagner是American Airlines的发言人，United是UAL Corp.的一个单位，American是AMR的一个单位。这些二元关系是更通用关系的实例，比如part-of或employes，它们在新闻风格的文本中出现得相当频繁。图17.1列出了ACE关系提取评估中使用的17种关系，图17.2显示了一些关系的样例。我们还可以提取更多的特定领域的关系，比如航空路线的概念。例如从这个文本中我们可以得出美联航有到芝加哥、达拉斯、丹佛和旧金山的航线。</p>
<center>
<img src="https://i.loli.net/2021/03/18/B5QEbCoyKd6ZsFi.png"  alt="" width="700" />
</center>
<table>
<thead>
<tr class="header">
<th>Relations</th>
<th>Types Examples</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Physical-Located</td>
<td>PER-GPE He was in Tennessee</td>
</tr>
<tr class="even">
<td>Part-Whole-Subsidiary</td>
<td>ORG-ORG XYZ, the parent company of ABC</td>
</tr>
<tr class="odd">
<td>Person-Social-Family</td>
<td>PER-PER Yoko鈥檚 husband John</td>
</tr>
<tr class="even">
<td>Org-AFF-Founder</td>
<td>PER-ORG Steve Jobs, co-founder of Apple...</td>
</tr>
</tbody>
</table>
<p>Figure 17.2 Semantic relations with examples and the named entity types they involve.</p>
<p>这些关系很好地对应了我们在第15章中引入的模型理论概念，为逻辑形式的含义提供了基础。也就是说，一个关系由一系列有序的元组组成，基于一个领域的元素。在大多数标准的信息提取应用中，领域元素对应于文本中出现的命名实体，对应于指代消歧产生的基础实体，或者对应于从领域本体中选择的实体。图 17.3 显示了一个基于模型的视图，可以从我们的运行示例中提取实体和关系的集合。</p>
<table>
<colgroup>
<col style="width: 60%" />
<col style="width: 39%" />
</colgroup>
<thead>
<tr class="header">
<th>Domain领域</th>
<th><span class="math inline">\(D = {a,b, c,d, e, f,g,h,i}\)</span>元素</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>United, UAL, American Airlines, AMR</td>
<td><span class="math inline">\(a,b, c,d\)</span></td>
</tr>
<tr class="even">
<td>Tim Wagner</td>
<td><span class="math inline">\(e\)</span></td>
</tr>
<tr class="odd">
<td>Chicago, Dallas, Denver, and San Francisco</td>
<td><span class="math inline">\(f,g,h,i\)</span></td>
</tr>
<tr class="even">
<td><strong>Classes类别</strong></td>
<td></td>
</tr>
<tr class="odd">
<td>United, UAL, American, and AMR are organizations</td>
<td><span class="math inline">\(Org = {a,b, c,d}\)</span></td>
</tr>
<tr class="even">
<td>Tim Wagner is a person</td>
<td><span class="math inline">\(Pers = {e}\)</span></td>
</tr>
<tr class="odd">
<td>Chicago, Dallas, Denver, and San Francisco are places</td>
<td><span class="math inline">\(Loc = { f,g,h,i}\)</span></td>
</tr>
<tr class="even">
<td><strong>Relations关系</strong></td>
<td></td>
</tr>
<tr class="odd">
<td>United is a unit of UAL</td>
<td><span class="math inline">\(PartOf = {&lt;a,b&gt;,&lt;c,d&gt;}\)</span></td>
</tr>
<tr class="even">
<td>American is a unit of AMR</td>
<td></td>
</tr>
<tr class="odd">
<td>Tim Wagner works for American Airlines</td>
<td><span class="math inline">\(OrgAff = {&lt;c, e&gt;}\)</span></td>
</tr>
<tr class="even">
<td>United serves Chicago, Dallas, Denver, and San Francisco</td>
<td><span class="math inline">\(Serves = {&lt;a, f&gt;,&lt;a,g&gt;,&lt;a,h&gt;,&lt;a,i&gt;}\)</span></td>
</tr>
</tbody>
</table>
<p>请注意这种模型理论的角度是如何将NER任务也包含在内的；命名实体识别对应于一类一元关系的识别。</p>
<p>许多其他领域都定义了关系集。例如美国国家医学图书馆的统一医学语言系统（UMLS）有一个网络，定义了134个大的主题类别、实体类型和54个实体之间的关系，示例如下。</p>
<table>
<thead>
<tr class="header">
<th>Entity</th>
<th>Relation</th>
<th>Entity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Injury</td>
<td>disrupts</td>
<td>Physiological Function</td>
</tr>
<tr class="even">
<td>Bodily Location</td>
<td>location-of</td>
<td>Biologic Function</td>
</tr>
<tr class="odd">
<td>Anatomical Structure</td>
<td>part-of</td>
<td>Organism</td>
</tr>
<tr class="even">
<td>Pharmacologic Substance</td>
<td>causes</td>
<td>Pathological Function</td>
</tr>
<tr class="odd">
<td>Pharmacologic Substance</td>
<td>treats</td>
<td>Pathologic Function</td>
</tr>
</tbody>
</table>
<p>给出这样一个医学句子：</p>
<blockquote>
<p>(17.1) Doppler echocardiography can be used to diagnose left anterior descending artery stenosis in patients with type 2 diabetes</p>
<p>多普勒超声心动图可以用来诊断2型糖尿病患者的左前降支动脉狭窄</p>
</blockquote>
<p>我们可以提取UMLS关系：</p>
<blockquote>
<p>Echocardiography, Doppler Diagnoses Acquired stenosis</p>
<p>超声心动图，多普勒诊断获得性狭窄</p>
</blockquote>
<p>维基百科也提供了大量的关系，这些关系来自于<u>信息框</u>(infoboxes)，即与某些维基百科文章相关的结构化表格。例如，维基百科上斯坦福（Stanford）的信息框包括诸如state = "California"或president = "Marc Tessier-Lavigne"这样的结构化事实。这些事实可以转化为president-of或located-in，或转化为一种称为<u>RDF</u>（Resource Description Framework，资源描述框架）的元语言中的关系。一个RDF triple是实体-关系-实体构成的元组，被称为主-谓-宾（subject-predicate-object）表达式。下面是一个RDF三元组的实例：</p>
<table>
<thead>
<tr class="header">
<th>subject</th>
<th>predicate</th>
<th>object</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Golden Gate Park</td>
<td>location</td>
<td>San Francisco</td>
</tr>
</tbody>
</table>
<p>例如众包的DBpedia (Bizer et al., 2009) 是一个从维基百科衍生出来的本体，包含超过20亿个RDF三元组。另一个来自维基百科信息框的数据集Freebase (Bollacker et al., 2008)，现在是Wikidata的一部分 (Vrandeciˇ c and Kr ´ otzsch, 2014)，涵盖了人员和他们的国籍或位置以及他们出现在的其他位置之间的关系。WordNet 或其他本体提供了有用的本体关系，描述了词或概念之间的层级关系。例如WordNet在类之间有is-a或hypernym的关系：</p>
<blockquote>
<p>Giraffe is-a ruminant is-a ungulate is-a mammal is-a vertebrate ...</p>
<p>长颈鹿是反刍动物是蹄类动物是哺乳动物是脊椎动物</p>
</blockquote>
<p>WordNet也有个体和类之间的Instance-of关系，例如San Francisco就和city处于Instance-of关系。提取这些关系是扩展或构建本体的重要步骤。</p>
<p>最后，有一些大型的数据集，其中包含了手动标注的句子和它们的关系，用于训练和测试关系提取器。TACRED数据集 (Zhang et al., 2017) 包含106,264个关于特定人或组织的关系三元组的例子，在来自年度TAC知识库人口（TAC KBP）挑战赛的新闻和网络文本的句子中标记得来。TACRED包含41种关系类型（如per:出生城市、org:子公司、org:成员、per:配偶），以及一个无关系标签；如图17.4所示。大约80%的例子都被标注为无关系；拥有足够的负数据对于训练监督分类器非常重要。</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 49%" />
</colgroup>
<thead>
<tr class="header">
<th>Example</th>
<th>Entity Types Label</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Carey will succeed <strong>Cathleen P. Black</strong>, who held the position for 15 years and will take on a new role as <u>chairwoman</u> of Hearst Magazines, the company said.</td>
<td><strong>PERSON</strong>/<u>TITLE</u><br/>Relation: <em>per:title</em></td>
</tr>
<tr class="even">
<td><strong>Irene Morgan Kirkaldy</strong>, who was born and reared in <u>Baltimore</u>, lived on Long Island and ran a child-care center in Queens with her second husband, Stanley Kirkaldy.</td>
<td><strong>PERSON</strong>/<u>CITY</u><br/>Relation: <em>per:city of birth</em></td>
</tr>
<tr class="odd">
<td><strong>Baldwin</strong> declined further comment, and said JetBlue chief <u>executive</u> Dave Barger was unavailable.</td>
<td>Types: <strong>PERSON</strong>/<u>TITLE</u><br/>Relation: <em>no relation</em></td>
</tr>
</tbody>
</table>
<p>SemEval 2010任务8也推出了一个标准数据集，检测命名词（nominal）之间的关系 (Hendrickx et al., 2009)。该数据集有10,717个例子，每个例子都有一个命名词对（未分类），手工标注为9个定向关系之一，比如产品-生产者<em>product-producer</em> (一家工厂生产西装 <em>a factory manufactures suits</em>) ，或者成分-整体<em>component-whole</em> (我的公寓有一个大厨房 <em>my apartment has a large kitchen</em>)。</p>
<h1 id="关系提取算法">17.2 关系提取算法</h1>
<p>关系提取的算法主要有五类：<strong>手写模式</strong>、监督机器学习、<strong>半监督</strong>（通过<strong>bootstrapping</strong>和通过远端监督）和<strong>无监督</strong>。我们将在接下来的章节中分别介绍这些算法。</p>
<h2 id="使用模式提取关系">17.2.1 使用模式提取关系</h2>
<p>最早也是目前常用的关系提取算法是词法-句法模式（ <strong>lexico-syntactic pattern</strong>），最早是由Hearst（1992a）开发的，因此通常被称为<u>Hearst模式</u>。看看以下句子：</p>
<blockquote>
<p>Agar is a substance prepared from a mixture of red algae, such as Gelidium, for laboratory or industrial use.</p>
<p>琼脂是一种由红藻（如Gelidium）混合制备的物质，用于实验室或工业用途。</p>
</blockquote>
<p>赫斯特指出，大多数人类读者不会知道Gelidium是什么，但他们可以很容易推断出它是一种红藻（下义词）。她认为以下词法-句法模式：</p>
<p><span class="math display">\[
N P_{0} \text { such as } N P_{1}\left\{, N P_{2} \ldots,(\text { and } \mid \text { or }) N P_{i}\right\}, i \geq 1
\]</span></p>
<p>意味着以下语义 <span class="math display">\[
\forall N P_{i}, i \geq 1, \text { hyponym }\left(N P_{i}, N P_{0}\right)
\]</span> 让我们可以推断 <span class="math display">\[
\forall N P_{i}, i \geq 1, \text { hyponym }\left(N P_{i}, N P_{0}\right)
\]</span></p>
<p>图17.5显示了Hearst(1992a, 1998)提出的五种模式，用于推断连词关系；我们将NP<sub>H</sub>显示为parent/hyponym。现代版本的基于模式的方法通过增加命名实体约束来扩展它。例如，如果我们的目标是回答关于 "谁在哪个组织中担任什么职务 "的问题，我们可以使用如下模式。</p>
<p><img src="https://i.loli.net/2021/03/18/iyZINETdVrXG3cn.png" width="500"/></p>
<p>手工构建的模式具有高精度的优势，并且可以针对特定领域进行定制。但另一方面，它们通常是低召回率的，而且如果要创建所有可能的模式，工作量很大。</p>
<h2 id="通过监督学习进行关系提取">17.2.2 通过监督学习进行关系提取</h2>
<p>监督机器学习的关系提取方法遵循的是一种大家现在应该很熟悉的方案。选择一组固定的关系和实体，用关系和实体手工标注训练语料，然后用标注后的文本来训练分类器标注一个未出现过的测试集。</p>
<p>最直接的方法，如图17.6所示：(1) 找到命名的实体对(通常在同一个句子中)；(2): 对每对实体进行关系分类。分类器可以使用任何监督技术（逻辑回归、RNN、Transformer、随机森林等）。一个可选的中间过滤分类器可以用来加快处理速度，通过二元决策判定给定的一对实体是否相关（通过任何关系）。它的训练对象是直接从标注语料中的所有关系中提取的正例，以及从未被标注为关系的句内实体对中产生的负例。</p>
<p>基于特征的有监督的关系分类器。让我们考虑基于特征的分类器（如逻辑回归或随机森林）的样本特征，从这个句子中对美国航空公司（Mention 1，或M1）和Tim Wagner（Mention 2，M2）之间的关系进行分类。</p>
<blockquote>
<p>(17.5) American Airlines, a unit of AMR, immediately matched the move, spokesman Tim Wagner said</p>
</blockquote>
<p>这些包括词的特征（如词嵌入、one-hot、无论是否提取词干<em>stemming</em>）：</p>
<ul>
<li><p>M1和M2的词头及其连接词 <em>The headwords of M1 and M2 and their concatenation</em></p>
<p><strong>Airlines Wagner Airlines-Wagner</strong></p></li>
<li><p>M1和M2的词袋和二元语法 <em>Bag-of-words and bigrams in M1 and M2</em></p>
<p><strong>American, Airlines, Tim, Wagner, American Airlines, Tim Wagner</strong></p></li>
<li><p>特定位置的词和二元语法 <em>Words or bigrams in particular positions</em></p>
<p>M2: <strong>-1 spokesman</strong></p>
<p>M2: <strong>+1 said</strong></p></li>
<li><p>M1和M2之间的词袋或二元语法 <em>Bag of words or bigrams between M1 and M2</em>:</p>
<p><strong>a, AMR, of, immediately, matched, move, spokesman, the, unit</strong></p></li>
</ul>
<p>以及命名实体特征：</p>
<ul>
<li><p>命名实体类型及其连接词 Named-entity types and their concatenation</p>
<p>(M1: <strong>ORG</strong>, M2: PER, M1M2: <strong>ORG-PER</strong>)</p></li>
</ul>
<p><img src="https://i.loli.net/2021/03/18/mpbfZs9QJoPnv7a.png" width="700"/></p>
<ul>
<li><p>M1和M2的实体级别（从集合NAME、NOMINAL、PRONOUN中选择）。 M1: NAME [it or he would be PRONOUN]</p>
<p>M2: NAME [the company would be NOMINAL]</p></li>
<li><p>参数之间的实体数量（在本例中，对于AMR）。</p></li>
</ul>
<p>句法结构是一个有用的信号，通常表示为依存关系或穿越实体之间的树的成分语法路径。</p>
<ul>
<li><p>M1和M2之间的成分路径 <strong>NP ↑ NP ↑ S ↑ S ↓ NP</strong></p></li>
<li><p>依存树路径</p>
<p><strong>Airlines ←sub<sub>j</sub> matched ←comp said →sub<sub>j</sub> Wagner</strong></p></li>
</ul>
<p><strong>神经监督关系分类器</strong> 关系提取的神经模型同样将任务视为监督分类。让我们考虑一个应用于TACRED关系提取数据集和任务的典型系统（Zhang等人，2017）。在TACRED中，提供一个句子和其中的两个spans：一个主语，即人或组织，一个宾语，即任何其他实体。任务是从42个TAC关系中分配一个关系（或者没有关系）。</p>
<p>一个典型的Transformer-encoder算法，如图17.7所示，简单的说就是把一个像BERT这样的预训练编码器，在句子表示的基础上增加一个线性层（例如BERT[CLS]token），这个线性层被微调为1-of-N分类器，以分配43个标签中的一个。BERT编码器的输入是部分去词汇化的；主语和宾语实体在输入中被其NER标签所取代。这有助于保持系统对单个词项的过度拟合 (Zhang et al., 2017) 。当使用BERT类型的Transformers进行关系提取时，使用BERT的版本，如RoBERTa (Liu et al., 2019) 或SPANbert (Joshi et al., 2020)，有助于使用BERT的版本，这些版本没有用[SEP]标记分隔的两个序列，而是从单个长序列的句子形成输入。</p>
<p>一般来说，如果测试集与训练集足够相似，如果有足够多的手工标注数据，监督关系提取系统可以获得很高的准确率。但对一个庞大的训练集进行标注是非常昂贵的，而且监督模型也很脆弱：它们不能很好地泛化到不同的文本类型。由于这个原因，关系提取的很多研究都集中在我们接下来要讲的半监督和无监督方法上。</p>
<hr />
<p><strong>本章剩余内容见：<a href="http://nlpcourse.cn/information-retrieval-2/">《自然语言处理综论》第17章-信息抽取（中）</a></strong></p>
]]></content>
      <categories>
        <category>自然语言处理</category>
        <category>信息抽取</category>
      </categories>
      <tags>
        <tag>nlp</tag>
        <tag>IR</tag>
      </tags>
  </entry>
  <entry>
    <title>用python处理json数据</title>
    <url>/json/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://baike.baidu.com/item/JSON">JSON</a>(<a href="https://baike.baidu.com/item/JavaScript">JavaScript</a> Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式。它基于 <a href="https://baike.baidu.com/item/ECMAScript">ECMAScript</a> (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。——百度百科</p>
</blockquote>
<p>编码和解码JSON数据的过程相当于把同一样东西翻译成中文和日语。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">json_str = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;example&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="comment"># 序列化json</span></span><br><span class="line">json_str = json.dumps(params, sort_keys=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 反序列化json</span></span><br><span class="line">dict_json = json.loads(json_str)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h1 id="序列化json">序列化JSON</h1>
<h2 id="将python对象转换为json">将Python对象转换为JSON</h2>
<table>
<thead>
<tr class="header">
<th>Python</th>
<th>JSON格式</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>dict</code></td>
<td><code>object</code></td>
</tr>
<tr class="even">
<td><code>list</code>， <code>tuple</code></td>
<td><code>array</code></td>
</tr>
<tr class="odd">
<td><code>str</code></td>
<td><code>string</code></td>
</tr>
<tr class="even">
<td><code>int</code>，<code>long</code>，<code>float</code></td>
<td><code>number</code></td>
</tr>
<tr class="odd">
<td><code>True</code></td>
<td><code>true</code></td>
</tr>
<tr class="even">
<td><code>False</code></td>
<td><code>false</code></td>
</tr>
<tr class="odd">
<td><code>None</code></td>
<td><code>null</code></td>
</tr>
</tbody>
</table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;president&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Zaphod Beeblebrox&quot;</span>,</span><br><span class="line">        <span class="string">&quot;species&quot;</span>: <span class="string">&quot;Betelgeusian&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">type</span>(data)</span><br><span class="line"><span class="comment">#&lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存为json文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data_file.json&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> write_file:</span><br><span class="line">    json.dump(data, write_file)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者将序列化的JSON数据写入python字符串对象</span></span><br><span class="line">json_string = json.dumps(data)</span><br><span class="line"><span class="comment"># &lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="一些有用的关键字参数">一些有用的关键字参数</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">json.dumps(data, indent=<span class="number">4</span>, sort_keys = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>indent定义缩进的级别；如果<em>sort_keys</em>为true，则字典的输出将按key排序。</p>
<h1 id="反序列化json读取json数据">反序列化JSON：读取JSON数据</h1>
<h2 id="将json编码的数据转换为python对象">将JSON编码的数据转换为Python对象</h2>
<table>
<thead>
<tr class="header">
<th>JSON</th>
<th>Python</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>object</code></td>
<td><code>dict</code></td>
</tr>
<tr class="even">
<td><code>array</code></td>
<td><code>list</code></td>
</tr>
<tr class="odd">
<td><code>string</code></td>
<td><code>str</code></td>
</tr>
<tr class="even">
<td><code>number</code> (int)</td>
<td><code>int</code></td>
</tr>
<tr class="odd">
<td><code>number</code> (real)</td>
<td><code>float</code></td>
</tr>
<tr class="even">
<td><code>true</code></td>
<td><code>True</code></td>
</tr>
<tr class="odd">
<td><code>false</code></td>
<td><code>False</code></td>
</tr>
<tr class="even">
<td><code>null</code></td>
<td><code>None</code></td>
</tr>
</tbody>
</table>
<h2 id="从文件中读取">从文件中读取</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;data_file.json&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> read_file:</span><br><span class="line">    data = json.load(read_file)</span><br><span class="line"><span class="built_in">type</span>(data)</span><br><span class="line"><span class="comment"># &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"><span class="built_in">type</span>(data[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># &lt;class &#x27;dict&#x27;&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="从字符串创建">从字符串创建</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">json_string = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;researcher&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;name&quot;: &quot;Ford Prefect&quot;,</span></span><br><span class="line"><span class="string">        &quot;species&quot;: &quot;Betelgeusian&quot;,</span></span><br><span class="line"><span class="string">        &quot;relatives&quot;: [</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                &quot;name&quot;: &quot;Zaphod Beeblebrox&quot;,</span></span><br><span class="line"><span class="string">                &quot;species&quot;: &quot;Betelgeusian&quot;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">data = json.loads(json_string)</span><br></pre></td></tr></table></figure>
<h2 id="从api获取">从API获取</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">&quot;https://jsonplaceholder.typicode.com/todos&quot;</span>)</span><br><span class="line">todos = json.loads(response.text)</span><br><span class="line">todos == response.json()</span><br></pre></td></tr></table></figure>
<p>这里的伪json数据适合用来练习。</p>
<h1 id="遍历json字符串">遍历JSON字符串</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">items &#x3D; data.items()</span><br><span class="line">for key, value in items:</span><br><span class="line">    print(str(key) + &#39;&#x3D;&#39; + str(value))</span><br></pre></td></tr></table></figure>
<p><strong>参考文献：</strong></p>
<p>https://realpython.com/python-json/</p>
]]></content>
      <categories>
        <category>代码</category>
        <category>文本处理</category>
      </categories>
      <tags>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>信息抽取技术综述</title>
    <url>/information-retrieval/</url>
    <content><![CDATA[<p>信息抽取是指从非结构化或半结构化文本中寻找结构化信息的任务。它是文本挖掘的一项重要任务，在自然语言处理、信息检索和网络挖掘等各个领域得到了广泛的研究。 <span id="more"></span> <strong>信息抽取(Information Extraction, IE)的两个基本任务：</strong></p>
<ul>
<li><p><strong>命名实体识别</strong>：识别实体的名称，如人、组织和地点。</p></li>
<li><p><strong>关系抽取</strong>：提取实体之间的语义关系，如FounderOf和HeadquarteredIn。</p></li>
</ul>
<p>本文，我们将对过去几十年命名实体识别和关系抽取方面的主要工作进行综述。</p>
<h1 id="信息抽取系统">信息抽取系统</h1>
<p>命名实体识别、指代消歧和关系抽取等任务，是成熟的、特定领域的信息提取系统的基本支持组件。</p>
<p>例如，给定下面的英文句子，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In 1998, Larry Page and Sergey Brin founded Google Inc.</span><br><span class="line">1998年，Larry Page和Sergey Brin创立了Google公司。</span><br></pre></td></tr></table></figure>
<p>我们可以提取以下信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">FounderOf(Larry Page, Google Inc.),</span><br><span class="line">FounderOf(Sergey Brin, Google Inc.),</span><br><span class="line">FoundedIn(Google Inc., <span class="number">1998</span>).</span><br></pre></td></tr></table></figure>
<p>提取的信息可以被其他计算机系统（如搜索引擎和数据库管理系统）利用，为最终用户提供更好的服务。具体提取的信息类型和结构取决于特定应用的需要。下面给出一些信息提取的应用实例：</p>
<blockquote>
<ul>
<li>生物医学研究人员经常需要从大量的科学出版物中筛选出与特定基因、蛋白质或其他生物医学实体相关的发现。为了协助这项工作，基于关键词匹配的简单搜索可能并不足够，因为生物医学实体通常具有同义词和模糊的名称，因此很难准确地检索相关文档。因此，生物医学文献挖掘的一项关键任务是从文本中自动识别生物医学实体的提及，并将其与现有知识库（如FlyBase）中的相应条目链接起来。</li>
<li>金融专业人员经常需要从新闻文章中寻找特定的信息，以帮助他们进行日常决策。例如，一家金融公司可能需要知道在某个时间跨度内发生的所有公司收购，以及每次收购的细节。从文本中自动查找此类信息需要标准的信息提取技术，如命名实体识别和关系提取。</li>
<li>情报分析员审查大量文本，以搜索参与恐怖主义事件的人员、使用的武器和攻击目标等信息。虽然信息检索技术可以用来快速查找描述恐怖主义事件的文件，但需要信息提取技术来进一步确定这些文件中的具体信息单元。</li>
<li>随着网络的快速发展，搜索引擎已经成为人们日常生活中不可缺少的一部分，现在用户的搜索行为也更加了解。基于文档的词袋表示的搜索已经不能提供满意的结果。更高级的搜索问题，如实体搜索、结构化搜索和问题解答等，可以为用户提供更好的搜索体验。为了方便这些搜索功能，通常需要将信息提取作为一个预处理步骤，以丰富文档表示或填充基础数据库。</li>
</ul>
</blockquote>
<p>早期的信息提取系统，如参与MUCs的系统，通常是基于规则的系统（如[32，42]）。它们使用人类开发的语言提取模式来匹配文本和定位信息单元。它们可以在特定的目标域上取得很好的性能，但是设计好的提取规则需要耗费大量的人力，而且开发的规则对领域的依赖性很强。意识到这些人工开发系统的局限性，研究人员转而采用统计机器学习的方法。而随着信息提取系统被分解为命名实体识别等组件，许多信息提取子任务可以转化为分类问题，这些问题可以通过标准的监督学习算法，如支持向量机和最大熵模型来解决。由于信息提取涉及到识别扮演不同角色的文本片段，序列标签方法，如隐藏马尔科夫模型和条件随机场也得到了广泛的应用。</p>
<p>在本章中，我们将重点关注信息提取中最基本的两个任务，即命名实体识别和关系提取。这两个任务的最先进的解决方案都依赖于统计机器学习方法。我们还讨论了传统上没有引起太多关注的无监督信息提取。本章的其余部分组织如下。第2节讨论了当前命名实体识别的方法，包括基于规则的方法和统计学习方法。第3节讨论了完全监督环境和弱监督环境下的关系提取。然后，我们在第4节讨论了无监督的关系发现和开放的信息提取。在第5节中，我们讨论了信息提取系统的评估。最后我们在第6节中总结。</p>
<h2 id="模板填充"><strong>模板填充</strong></h2>
<p>如图的恐怖主义模板中，左边是槽位子集，右边是槽位填充值。</p>
<p>其中一些槽位填充值，如"Enrique Ormazabal Ormazabal"和 "商人"是直接从文本中提取的，而其他的槽位填充值，如抢劫、完成、枪支等则是根据文档从对应槽位的预定义值集中选择的。</p>
<p><img width=500 src="https://i.loli.net/2021/03/09/An4ryIzRKLDSTsg.png"/></p>
<h1 id="有监督的方法">有监督的方法</h1>
<p>传统的信息提取任务对提取信息的结构有明确的定义，例如命名实体的类型、关系的类型、或者模板槽。在某些场景下，我们事先并不知道我们想要提取的信息结构，而希望从大型语料库中挖掘这样的结构。例如，从一组地震新闻文章中，我们可能希望自动发现地震的日期、时间、震中、震级和伤亡是新闻文章中报道的最重要的信息。</p>
<p>最近已经有一些关于这类无监督信息提取问题的研究，但总体上沿着这个方向的工作仍然有限。另一个新的方向是开放信息提取，系统要从Web这样一个庞大的、多样化的语料库中提取所有有用的实体关系。这种系统的输出不仅包括关系中涉及的论据，还包括从文本中提取的关系的描述。最近在这个方向上取得的进展包括TextRunner[6]、Woe[66]和ReVerb[29]等系统。</p>
<h1 id="无监督的方法">无监督的方法</h1>
<h2 id="现存系统">现存系统</h2>
<p>TextRunner</p>
<p>Woe</p>
<p>ReVerb</p>
<h2 id="术语解释">术语解释</h2>
<p>国防高级研究计划局, Defense Advanced Research Projects Agency, DARPA</p>
<p>消息理解会议, Message Understanding Conferences, MUC (DARPA发起并资助)</p>
<p>DeJong的FRUMP计划</p>
<h2 id="监督学习算法">监督学习算法</h2>
<h2 id="序列标注方法">序列标注方法</h2>
<h1 id="命名实体识别">命名实体识别</h1>
<p><strong>命名实体</strong>：指代某种现实世界实体的词语序列，例如“California,” “Steve Jobs” and “Apple Inc.”。</p>
<p><strong>命名实体识别（NER）</strong>：从自由形式的文本中识别出命名实体，并将其分类为一组预定义的类型，如人名、组织和地点。</p>
<p>命名实体识别是信息提取中最基本的任务。关系和事件提取等更复杂的任务，需要准确的命名实体识别作为基础。</p>
<p>通常情况下，这项任务不能简单地通过与预先编译的地名录进行字符串匹配来完成，因为给定实体类型的命名实体通常不会形成一个封闭的集合，任何地名录都是不完整的。另一个原因是，命名实体的类型可能取决于上下文。例如，"JFK "可能指的是 "John F. Kennedy"这个人或者"JFK International Airport "这个地点，或任何其他具有相同缩写的实体。为了确定在特定文档中出现的 "JFK "的实体类型，必须考虑其上下文。</p>
<p>NER已有多个评估项目，包括自动内容提取(ACE)项目、2002年和2003年自然语言学习会议(CoNLL)的共享任务[63]、BioCreAtIvE(Critical Assessment of Information Extraction Systems in Biology)挑战评估[2]。</p>
<p>最常研究的命名实体类型是人名、组织和地点，这是由MUC-6首次定义的。这些类型足够通用，对许多应用领域都有用。日期、时间、货币值和百分比等表达式的提取，也是由MUC-6引入的，通常也是在NER下研究的，尽管严格来说这些表达式不是命名实体。除了这些一般的实体类型外，其他类型的实体通常是针对特定领域和应用而定义的。例如，GENIA语料库使用细粒度的本体对生物实体进行分类[52]。在在线搜索和广告中，产品名称的提取是一项有用的任务。</p>
<p>参考文献：</p>
<p>https://zhuanlan.zhihu.com/p/266056681</p>
]]></content>
      <categories>
        <category>自然语言处理</category>
        <category>信息抽取</category>
      </categories>
      <tags>
        <tag>nlp</tag>
        <tag>IR</tag>
      </tags>
  </entry>
  <entry>
    <title>英文文献的命名实体识别（中）</title>
    <url>/named-entity-recognition-2/</url>
    <content><![CDATA[<p>命名实体识别（NER）是指自动识别文本中的命名实体并将其分类为预定义的类别。实体可以是人员、组织、位置、时间、数量、货币价值、百分比等的名称。作为信息抽取的基础步骤，NER从非结构化文本中提取关键元素，因此它是一项至关重要的技术。</p>
<p>我们可以创建自己的实体类别以适应不同的任务。现在有许多出色的开源库，包括<a href="https://www.nltk.org/">NLTK</a>，<a href="https://spacy.io/">SpaCy</a>和<a href="https://nlp.stanford.edu/software/CRF-NER.shtml">Stanford NER</a>。如何用这些工具实现，参考<a href="https://www.kdnuggets.com/2018/08/named-entity-recognition-practitioners-guide-nlp-4.html">命名实体识别：NLP从业人员指南</a>和<a href="https://towardsdatascience.com/named-entity-recognition-with-nltk-and-spacy-8c4a7d88e7da">NLTK和SpaCy命名实体识别</a>。也可以参考<a href="https://monkeylearn.com/blog/named-entity-recognition/">这篇</a>文章。</p>
<span id="more"></span>
<h2 id="学术文献">学术文献</h2>
<p>https://livebook.manning.com/book/natural-language-processing-in-action/chapter-11/</p>
<p>https://github.com/AmoDinho/datacamp-python-data-science-track/blob/master/Natural%20Language%20Processing%20Fundamentals%20in%20Python/Chapter%203%20-Named-entity%20recognition.py</p>
<p>https://www.sciencedirect.com/topics/computer-science/named-entity-recognition</p>
<p>https://www.nltk.org/book/ch07.html</p>
<p>明天要翻译的文献：信息抽取</p>
<p>https://web.stanford.edu/~jurafsky/slp3/17.pdf</p>
<h1 id="如何训练ner分类器">如何训练NER分类器</h1>
<p>通常使用BIO表示法，该表示法区分实体的开始（B）和内部（I），O标记非实体。NER往往需要特定领域的训练，尤其是更细粒度的NER。</p>
<h2 id="评估">评估</h2>
<p><em>F-Score</em>是用于评估NER的一种常用度量，它是Precision和Recall的组合。Precision, recall, and F-Score are defined as follows (<a href="https://www.frontiersin.org/articles/10.3389/fcell.2020.00673/full#B21">Campos et al., 2012</a>):</p>
<p><span class="math display">\[
\begin{array}{c}
\text { Precision }=\frac{\text { Relevant Names Recognized }}{\text { Total Names Recognized }} \\
=\frac{\text { True Positives }}{\text { True Positives+False Positives }} \\
\text { Recall }=\frac{\text { Relevant Names Recognized }}{\text { Relevant Names in Corpus }} \\
=\frac{\text { True Positives }}{\text { True Positives+False Negatives }} \\
\text { F-score }=2 \times \frac{\text { Precision } \times \text { Recall }}{\text { Precision+Recáll }}
\end{array}
\]</span></p>
]]></content>
      <categories>
        <category>自然语言处理</category>
        <category>命名实体识别</category>
      </categories>
      <tags>
        <tag>nlp</tag>
        <tag>NER</tag>
      </tags>
  </entry>
  <entry>
    <title>英文文献的命名实体识别（上）</title>
    <url>/named-entity-recognition/</url>
    <content><![CDATA[<p>命名实体识别（NER）是指自动识别文本中的命名实体并将其分类为预定义的类别。实体可以是人员、组织、位置、时间、数量、货币价值、百分比等的名称。作为信息抽取的基础步骤，NER从非结构化文本中提取关键元素，因此它是一项至关重要的技术。</p>
<p>我们可以创建自己的实体类别以适应不同的任务。现在有许多出色的开源库，包括<a href="https://www.nltk.org/">NLTK</a>，<a href="https://spacy.io/">SpaCy</a>和<a href="https://nlp.stanford.edu/software/CRF-NER.shtml">Stanford NER</a>。如何用这些工具实现，参考<a href="https://www.kdnuggets.com/2018/08/named-entity-recognition-practitioners-guide-nlp-4.html">命名实体识别：NLP从业人员指南</a>和<a href="https://towardsdatascience.com/named-entity-recognition-with-nltk-and-spacy-8c4a7d88e7da">NLTK和SpaCy命名实体识别</a>。也可以参考<a href="https://monkeylearn.com/blog/named-entity-recognition/">这篇</a>文章。</p>
<span id="more"></span>
<h2 id="学术文献">学术文献</h2>
<p><a href="https://www.frontiersin.org/articles/10.3389/fcell.2020.00673/full">用于生物医学信息提取的命名实体识别和关系检测</a></p>
<p><a href="https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-019-3321-4">使用具有上下文信息的深度神经网络进行生物医学命名实体识别</a></p>
<p><a href="https://www.sciencedirect.com/science/article/abs/pii/S0885230815300504">用于命名实体识别工具的多领域评估框架</a></p>
<p><a href="https://devopedia.org/named-entity-recognition#Wang-et-al.-2019">命名实体识别</a></p>
<p><a href="https://paperswithcode.com/task/named-entity-recognition-ner">带代码的文献</a></p>
<h1 id="如何训练ner分类器">如何训练NER分类器</h1>
<p>通常使用BIO表示法，该表示法区分实体的开始（B）和内部（I），O标记非实体。NER往往需要特定领域的训练，尤其是更细粒度的NER。</p>
<h2 id="评估">评估</h2>
<p><em>F-Score</em>是用于评估NER的一种常用度量，它是Precision和Recall的组合。Precision, recall, and F-Score are defined as follows (<a href="https://www.frontiersin.org/articles/10.3389/fcell.2020.00673/full#B21">Campos et al., 2012</a>):</p>
<p><span class="math display">\[
\begin{array}{c}
\text { Precision }=\frac{\text { Relevant Names Recognized }}{\text { Total Names Recognized }} \\
=\frac{\text { True Positives }}{\text { True Positives+False Positives }} \\
\text { Recall }=\frac{\text { Relevant Names Recognized }}{\text { Relevant Names in Corpus }} \\
=\frac{\text { True Positives }}{\text { True Positives+False Negatives }} \\
\text { F-score }=2 \times \frac{\text { Precision } \times \text { Recall }}{\text { Precision+Recáll }}
\end{array}
\]</span></p>
]]></content>
      <categories>
        <category>自然语言处理</category>
        <category>命名实体识别</category>
      </categories>
      <tags>
        <tag>nlp</tag>
        <tag>NER</tag>
      </tags>
  </entry>
  <entry>
    <title>PDF文件处理大全</title>
    <url>/pdf/</url>
    <content><![CDATA[<h1 id="pdfplumberpdf文件预处理">Pdfplumber：PDF文件预处理</h1>
<h2 id="用pdfminer把pdf转为txt">用pdfminer把pdf转为txt</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pdfminer.high_level <span class="keyword">import</span> extract_text</span><br><span class="line">file_path = <span class="string">r&#x27;D:\pdf-file\Psychology_of_Language.pdf&#x27;</span></span><br><span class="line">text = extract_text(file_path, page_numbers=<span class="built_in">range</span>(<span class="number">33</span>,<span class="number">35</span>))</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><code>pdfminer.high_level.``extract_text</code>（<em>pdf_file</em>，<em>password =''</em>，<em>page_numbers = None</em>，<em>maxpages = 0</em>，<em>caching = True</em>，<em>codec ='utf-8'</em>，<em>laparams = None</em> ）</p>
<p>参考：https://pdfminersix.readthedocs.io/en/latest/reference/highlevel.html#api-extract-text</p>
<h2 id="更精确的转换除去换行符">更精确的转换（除去换行符）</h2>
<h3 id="少量文件转换">少量文件转换</h3>
<h4 id="先把pdf转换为word">先把pdf转换为word</h4>
<p>转换工具：https://pdf2doc.com/zh/</p>
<h4 id="然后把word转为txt">然后把word转为txt</h4>
<p>文件多的话用多线程PDF转Word：https://github.com/python-fan/pdf2word</p>
<h3 id="批量转换">批量转换</h3>
<p>还不知道，参考：https://www.zhihu.com/question/357994254</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pdfplumber</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">file_path = <span class="string">&#x27;book.pdf&#x27;</span></span><br><span class="line">pdf = pdfplumber.<span class="built_in">open</span>(file_path)</span><br><span class="line">start_page = <span class="number">34</span></span><br><span class="line">end_page = <span class="number">35</span></span><br><span class="line">text_string = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> page_num <span class="keyword">in</span> <span class="built_in">range</span>(start_page-<span class="number">1</span>, end_page):</span><br><span class="line">    text_string += pdf.pages[page_num].extract_text()+<span class="string">&#x27; &#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;book.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(text_string)</span><br></pre></td></tr></table></figure>
<h2 id="把表格保存为csv">把表格保存为csv</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pdfplumber</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">file_path = <span class="string">&#x27;book.pdf&#x27;</span></span><br><span class="line">pdf = pdfplumber.<span class="built_in">open</span>(file_path)</span><br><span class="line"></span><br><span class="line">chars = []</span><br><span class="line"><span class="keyword">for</span> page <span class="keyword">in</span> pdf.pages[<span class="number">7</span>:<span class="number">166</span>]:</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> page.chars:</span><br><span class="line">        chars.append(char)</span><br><span class="line">width_unique = <span class="built_in">set</span>([char[<span class="string">&#x27;height&#x27;</span>] <span class="keyword">for</span> char <span class="keyword">in</span> chars])</span><br><span class="line">print(<span class="string">&#x27;The unique heights: &#x27;</span>+<span class="built_in">str</span>(width_unique))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>代码</category>
        <category>文本处理</category>
      </categories>
      <tags>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title>英文词性标记（POS Tagging）</title>
    <url>/pos-tagging/</url>
    <content><![CDATA[<h1 id="词性标记pos-tagging">词性标记（POS Tagging）</h1>
<p>POS标签大致分为两种：通用POS标签和细粒度POS标签。</p>
<h2 id="跨语言的通用pos标签">跨语言的通用POS标签</h2>
<p>通用依存关系（<a href="https://universaldependencies.org/">UD</a>）是一个致力于开发跨语言树库标注的项目，为不同语言标注一致的语法<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>。 <span id="more"></span> 该标注方案基于（通用的）斯坦福依存关系（de Marneffe et al., 2006, 2008, 2014）、Google通用词性标签（Petrov et al., 2012）和Interset interlingua的形态语义标签集（Zeman, 2008）的发展进化。</p>
<p>该<a href="https://universaldependencies.org/u/pos/index.html">网站</a>列举了各个通用POS标签的详细解释。</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 14%" />
<col style="width: 34%" />
<col style="width: 18%" />
</colgroup>
<thead>
<tr class="header">
<th>Tag</th>
<th>Category</th>
<th>Explanation</th>
<th>Examples</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><a href="https://universaldependencies.org/u/pos/ADJ.html">ADJ</a></td>
<td>adjective</td>
<td>形容词，修饰名词或充当谓语</td>
<td>big, African, first</td>
</tr>
<tr class="even">
<td><a href="https://universaldependencies.org/u/pos/ADP.html">ADP</a></td>
<td>adposition</td>
<td>介词，包括前置词和后置词（prepositions and postpositions）</td>
<td>in, during</td>
</tr>
<tr class="odd">
<td><a href="https://universaldependencies.org/u/pos/ADV.html">ADV</a></td>
<td>adverb</td>
<td>副词，修饰动词、形容词和副词本身，表示时间、地点、方向或方式</td>
<td>very, up, tomorrow, where, never</td>
</tr>
<tr class="even">
<td><a href="https://universaldependencies.org/u/pos/AUX_.html">AUX</a></td>
<td>auxiliary</td>
<td>助词，包括Tense auxiliaries, Passive auxiliaries, Modal auxiliaries, Verbal copulas</td>
<td>has, was, should</td>
</tr>
<tr class="odd">
<td><a href="https://universaldependencies.org/u/pos/CCONJ.html">CCONJ</a></td>
<td>coordinating conjunction</td>
<td>并列连词</td>
<td>and, or, but</td>
</tr>
<tr class="even">
<td><a href="https://universaldependencies.org/u/pos/DET.html">DET</a></td>
<td>determiner</td>
<td>限定词，修饰名词</td>
<td>the, a, an</td>
</tr>
<tr class="odd">
<td><a href="https://universaldependencies.org/u/pos/INTJ.html">INTJ</a></td>
<td>interjection</td>
<td>感叹词</td>
<td>ouch, yes</td>
</tr>
<tr class="even">
<td><a href="https://universaldependencies.org/u/pos/NOUN.html">NOUN</a></td>
<td>noun</td>
<td>普通名词</td>
<td>girl, tree, air</td>
</tr>
<tr class="odd">
<td><a href="https://universaldependencies.org/u/pos/NUM.html">NUM</a></td>
<td>numeral</td>
<td>数词</td>
<td>2014, one, II</td>
</tr>
<tr class="even">
<td><a href="https://universaldependencies.org/u/pos/PART.html">PART</a></td>
<td>particle</td>
<td>小品词，与其他词语结合</td>
<td>'s, not</td>
</tr>
<tr class="odd">
<td><a href="https://universaldependencies.org/u/pos/PRON.html">PRON</a></td>
<td>pronoun</td>
<td>代词，代替名词或名词短语</td>
<td>you, who, somebody, it</td>
</tr>
<tr class="even">
<td><a href="https://universaldependencies.org/u/pos/PROPN.html">PROPN</a></td>
<td>proper noun</td>
<td>专有名词，特定任务、地点或物体的名称</td>
<td>Mary, London, NATO</td>
</tr>
<tr class="odd">
<td><a href="https://universaldependencies.org/u/pos/PUNCT.html">PUNCT</a></td>
<td>punctuation</td>
<td>标点符号是非字母字符和字符组</td>
<td>. , ()</td>
</tr>
<tr class="even">
<td><a href="https://universaldependencies.org/u/pos/SCONJ.html">SCONJ</a></td>
<td>subordinating conjunction</td>
<td>从属连词，引入从句的连词</td>
<td>since, that, who, if, while</td>
</tr>
<tr class="odd">
<td><a href="https://universaldependencies.org/u/pos/SYM.html">SYM</a></td>
<td>symbol</td>
<td>符号，可以用普通单词代替（比如$换作美元）</td>
<td>$, %, ♥‿♥, 😝</td>
</tr>
<tr class="even">
<td><a href="https://universaldependencies.org/u/pos/VERB.html">VERB</a></td>
<td>verb</td>
<td>动词，表示事件和动作</td>
<td>run, runs, running</td>
</tr>
<tr class="odd">
<td><a href="https://universaldependencies.org/u/pos/X.html">X</a></td>
<td>other</td>
<td>其他</td>
<td>xfgh</td>
</tr>
</tbody>
</table>
<p>该项目的<a href="https://github.com/UniversalDependencies/docs">Github地址</a>涵盖了不同语言。</p>
<h2 id="特定语言的细粒度pos标签">特定语言的细粒度POS标签</h2>
<p>我们可以将通用POS标签细化，例如将英语中的NOUN（普通名词）进一步划分为复数普通名词（NNS），NN（单数普通名词），但这些标签是基于特定语言的。</p>
<p>我们可以打开<a href="https://spacy.io/usage/linguistic-features">spacy</a>，线上运行以下代码。其中pos表示<a href="https://universaldependencies.org/docs/u/pos/">通用POS标签集</a>的粗粒度<a href="https://universaldependencies.org/docs/u/pos/">词性</a>，而tag表示细粒度的词性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line"></span><br><span class="line">nlp = spacy.load(<span class="string">&quot;en_core_web_sm&quot;</span>)</span><br><span class="line">doc = nlp(<span class="string">&quot;It took me more than two hours to translate a few pages of English.&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">	print(token.text, <span class="string">&#x27;=&gt;&#x27;</span>,token.pos_,<span class="string">&#x27;=&gt;&#x27;</span>,token.tag_)</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">It &#x3D;&gt; PRON &#x3D;&gt; PRP</span><br><span class="line">took &#x3D;&gt; VERB &#x3D;&gt; VBD</span><br><span class="line">me &#x3D;&gt; PRON &#x3D;&gt; PRP</span><br><span class="line">more &#x3D;&gt; ADJ &#x3D;&gt; JJR</span><br><span class="line">than &#x3D;&gt; SCONJ &#x3D;&gt; IN</span><br><span class="line">two &#x3D;&gt; NUM &#x3D;&gt; CD</span><br><span class="line">hours &#x3D;&gt; NOUN &#x3D;&gt; NNS</span><br><span class="line">to &#x3D;&gt; PART &#x3D;&gt; TO</span><br><span class="line">translate &#x3D;&gt; VERB &#x3D;&gt; VB</span><br><span class="line">a &#x3D;&gt; DET &#x3D;&gt; DT</span><br><span class="line">few &#x3D;&gt; ADJ &#x3D;&gt; JJ</span><br><span class="line">pages &#x3D;&gt; NOUN &#x3D;&gt; NNS</span><br><span class="line">of &#x3D;&gt; ADP &#x3D;&gt; IN</span><br><span class="line">English &#x3D;&gt; PROPN &#x3D;&gt; NNP</span><br><span class="line">. &#x3D;&gt; PUNCT &#x3D;&gt; .</span><br></pre></td></tr></table></figure>
<p>有关spaCy模型在不同语言中分配的细粒度和粗粒度词性标签的列表，请参阅<a href="https://spacy.io/models">models目录中</a>记录的标签方案。</p>
<p>比如英语的所有细粒度<a href="https://spacy.io/models/en">标签</a>如下：</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 85%" />
</colgroup>
<thead>
<tr class="header">
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>$</code></td>
<td>symbol, currency</td>
</tr>
<tr class="even">
<td><code>''</code></td>
<td>closing quotation mark</td>
</tr>
<tr class="odd">
<td><code>,</code></td>
<td>punctuation mark, comma</td>
</tr>
<tr class="even">
<td>```<code>| opening quotation mark                    | |</code>-LRB-<code>| left round bracket                        | |</code>-RRB-<code>| right round bracket                       | |</code>.<code>| punctuation mark, sentence closer         | |</code>:<code>| punctuation mark, colon or ellipsis       | |</code>ADD<code>| email                                     | |</code>AFX<code>| affix                                     | |</code>CC<code>| conjunction, coordinating                 | |</code>CD<code>| cardinal number                           | |</code>DT<code>| determiner                                | |</code>EX<code>| existential there                         | |</code>FW<code>| foreign word                              | |</code>HYPH<code>| punctuation mark, hyphen                  | |</code>IN<code>| conjunction, subordinating or preposition | |</code>JJ<code>| adjective                                 | |</code>JJR<code>| adjective, comparative                    | |</code>JJS<code>| adjective, superlative                    | |</code>LS<code>| list item marker                          | |</code>MD<code>| verb, modal auxiliary                     | |</code>NFP<code>| superfluous punctuation                   | |</code>NN<code>| noun, singular or mass                    | |</code>NNP<code>| noun, proper singular                     | |</code>NNPS<code>| noun, proper plural                       | |</code>NNS<code>| noun, plural                              | |</code>PDT<code>| predeterminer                             | |</code>POS<code>| possessive ending                         | |</code>PRP<code>| pronoun, personal                         | |</code>PRP<span class="math inline">\(` | pronoun, possessive | | `RB` | adverb | | `RBR` | adverb, comparative | | `RBS` | adverb, superlative | | `RP` | adverb, particle | | `SYM` | symbol | | `TO` | infinitival &quot;to | | `UH` | interjection | | `VB` | verb, base form | | `VBD` | verb, past tense | | `VBG` | verb, gerund or present participle | | `VBN` | verb, past participle | | `VBP` | verb, non-3rd person singular present | | `VBZ` | verb, 3rd person singular present | | `WDT` | wh-determiner | | `WP` | wh-pronoun, personal | | `WP\)</span><code>| wh-pronoun, possessive                    | |</code>WRB<code>| wh-adverb                                 | |</code>XX`</td>
<td>unknown</td>
</tr>
</tbody>
</table>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><a href="https://www.analyticsvidhya.com/blog/2020/07/part-of-speechpos-tagging-dependency-parsing-and-constituency-parsing-in-nlp/#:~:text=Dependency%20parsing%20is%20the%20process,tags%20are%20the%20dependency%20tags.">词性标记和依存关系分析</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>自然语言处理</category>
        <category>词性标注</category>
      </categories>
      <tags>
        <tag>nlp</tag>
        <tag>pos</tag>
      </tags>
  </entry>
  <entry>
    <title>心理语言学：资源和知识整理</title>
    <url>/psycho-linguistics/</url>
    <content><![CDATA[<h1 id="心理语言学知识大纲">心理语言学知识大纲</h1>
]]></content>
      <categories>
        <category>语言学</category>
        <category>心理语言学</category>
      </categories>
      <tags>
        <tag>psycholinguistics</tag>
      </tags>
  </entry>
  <entry>
    <title>一文读懂Flask Web开发实战！</title>
    <url>/flask-2/</url>
    <content><![CDATA[
]]></content>
      <categories>
        <category>网站开发</category>
        <category>flask</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>基础：用flask搭建RESTful API</title>
    <url>/flask-api-1/</url>
    <content><![CDATA[<p><a href="https://flask.palletsprojects.com/en/1.1.x/">Flask</a>是目前发展最迅速的 Python 框架之一，它是一个微型的 Python 开发的 Web 框架，基于<a href="https://www.oschina.net/p/werkzeug">Werkzeug</a> WSGI工具箱和<a href="https://www.oschina.net/p/jinja">Jinja2</a> 模板引擎。以下是用flask来构建 RESTful API 的全过程实录，力求完整、准确、无误地记录每个操作步骤与细节。我用的是windows系统，但我也会提到其他系统的操作。 <span id="more"></span> # 环境搭建与工具安装</p>
<p>首先依然是创建虚拟环境并安装 flask 和 <a href="https://flask-restful.readthedocs.io/en/latest/">flask-restful</a> package。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkvirtualenv flask-api</span><br><span class="line">pip install flask</span><br><span class="line">pip install flask-restful</span><br></pre></td></tr></table></figure>
<h1 id="使用flask搭建api">使用flask搭建API</h1>
<h2 id="最简单的flask应用">最简单的flask应用</h2>
<p>新建一个python脚本，linux用touch，windows操作如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">workon flask-api <span class="comment"># 激活虚拟环境</span></span><br><span class="line">D:</span><br><span class="line"><span class="built_in">type</span> nul&gt;hello.py <span class="comment"># 新建文件</span></span><br><span class="line">atom hello.py <span class="comment"># 用atom编辑器打开</span></span><br></pre></td></tr></table></figure>
<p>粘贴以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)  </span><span class="comment"># 把Flask对象中的route()函数作为一个装饰器，增强该函数的功能</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello, World!&#x27;</span></span><br></pre></td></tr></table></figure>
<p>再打开 Command Prompt 输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set FLASK_APP&#x3D;hello.py</span><br><span class="line">set FLASK_ENV&#x3D;development</span><br><span class="line">flask run</span><br></pre></td></tr></table></figure>
<p>按下快捷键Alt+Shift+=左右分屏，输入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://127.0.0.1:5000/</span><br><span class="line">curl -v http://127.0.0.1:5000/</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&lt; Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line">&lt; Content-Length: 13</span><br><span class="line">...</span><br><span class="line">&lt;</span><br><span class="line">Hello, World!* Closing connection 0</span><br></pre></td></tr></table></figure>
<p>我们发现返回的是html类型，而不是通常从 RESTful API 获得的 json 文件，于是修改hello.py的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;about&#x27;</span>: <span class="string">&#x27;Hello, World!&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者：</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world</span>():</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(about=<span class="string">&#x27;Hello, World!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>调试模式下，服务器会监测你的代码更新并自动加载，所以无须重启才看到效果。这时curl得到json file：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">&lt; Content-Type: application&#x2F;json</span><br><span class="line">&lt; Content-Length: 31</span><br><span class="line">...</span><br><span class="line">&lt;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;hello&quot;: &quot;Hello, World!&quot;</span><br><span class="line">&#125;</span><br><span class="line">* Closing connection 0</span><br></pre></td></tr></table></figure>
<h2 id="通过url传递参数">通过URL传递参数</h2>
<p>我们可以通过url传递参数给flask api，例如<code>/&lt;int:num&gt;/</code></p>
<p>将hello.py修改为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, jsonify, request</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/multi/&lt;int:num&gt;&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>]</span>) </span><span class="comment"># methods一般默认为GET</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_multiply10</span>(<span class="params">num</span>):</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;result&#x27;</span>: num*<span class="number">10</span>&#125;) <span class="comment"># 返回数字乘以10后的结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(debug=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>然后在cmd输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;multi&#x2F;10</span><br></pre></td></tr></table></figure>
<p>我们得到10乘以10后的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;result&quot;: 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，我们也可以在浏览器内访问以下地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;multi&#x2F;10</span><br></pre></td></tr></table></figure>
<h2 id="使用post方法">使用POST方法</h2>
<p>这一小节我们将使用POST method。</p>
<p>在hello.py中加入以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">if</span> (request.method == <span class="string">&quot;POST&quot;</span>):</span><br><span class="line">        some_json = request.get_json()</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;You sent&#x27;</span>: some_json&#125;), <span class="number">201</span> <span class="comment"># 如果是post则返回post内容</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> jsonify(&#123;<span class="string">&quot;about&quot;</span>: <span class="string">&quot;Hello World!&quot;</span>&#125;) <span class="comment"># 如果是get则返回hello world</span></span><br></pre></td></tr></table></figure>
<p>现在，我们可以发送如下curl请求并返回POST的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Content-Type: application&#x2F;json&quot; -X POST -d &#39;&#123;&quot;name&quot;:&quot;Example&quot;,&quot;email&quot;:&quot;example@example.com&quot;&#125;&#39; http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;</span><br></pre></td></tr></table></figure>
<p>注意：Windows的命令行不支持单引号、且需要将双引号转义，所以需要改成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Content-Type: application&#x2F;json&quot; -X POST -d &quot;&#123;\&quot;name\&quot;:\&quot;Example\&quot;,\&quot;email\&quot;:\&quot;example@example.com\&quot;&#125;&quot; http:&#x2F;&#x2F;127.0.0.1:5000&#x2F;</span><br></pre></td></tr></table></figure>
<p>因此，Windows用户建议在git bash上完成以上操作。</p>
<h1 id="使用flask-restful搭建api">使用flask-restful搭建API</h1>
<p>我们把hello.py修改为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"><span class="keyword">from</span> flask_restful <span class="keyword">import</span> Resource, Api</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">api = Api(app)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span>(<span class="params">Resource</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self</span>):</span></span><br><span class="line">        some_json = request.get_json()</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;You sent&#x27;</span>: some_json&#125;, <span class="number">201</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Multi</span>(<span class="params">Resource</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span>(<span class="params">self, num</span>):</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;result&#x27;</span>: num*<span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line">api.add_resource(HelloWorld, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">api.add_resource(Multi, <span class="string">&#x27;/multi/&lt;int:num&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>以上代码实现完全相同的功能，不过看起来更简洁和舒服。</p>
<p>参考教程：</p>
<p>https://www.youtube.com/watch?v=s_ht4AKnWZg</p>
<p>参考文献：</p>
<p>https://blog.csdn.net/weixin_41010198/article/details/85230424#API_3</p>
]]></content>
      <categories>
        <category>网站开发</category>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title>部署Flask开发的API到Heroku</title>
    <url>/flask-api-2/</url>
    <content><![CDATA[<p>上篇文章我们介绍了如何用flask开发简单的web api，下面我们把它部署到heroku上，方便更多人使用。 <span id="more"></span></p>
<p><strong>步骤总结：</strong></p>
<ul>
<li><p>注册<a href="https://signup.heroku.com/">Heroku帐号</a></p></li>
<li><p>下载客户端</p></li>
<li><p>在本地命令行登录</p>
<ul>
<li>如果出现IP Address Mismatch，复制并粘贴<code>heroku login -i</code>到终端，用邮箱密码登录</li>
</ul></li>
<li><p>创建应用</p>
<ul>
<li>``` heroku apps:create flask-microblog <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">- 初始化</span><br><span class="line">  </span><br><span class="line">  - &#96;&#96;&#96;</span><br><span class="line">    mkdir flask-api</span><br><span class="line">    cd flask-api</span><br><span class="line">    git init</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>编写应用代码</p>
<ul>
<li>run.py</li>
<li>requirements.txt</li>
<li><code>echo web: gunicorn run:app &gt; Procfile</code>
<ul>
<li><code>web: gunicorn &lt;filename&gt;:&lt;main method name&gt;</code></li>
</ul></li>
<li>用<code>tree/F</code>检验上述文件是否齐全</li>
</ul></li>
<li><p>部署应用</p>
<ul>
<li><p>关联github，自动部署</p></li>
<li><pre><code>  git add .
  git commit -m &quot;Initialize repo&quot;
  git push -u origin master</code></pre></li>
</ul></li>
<li><p>访问应用地址：https://nlp-ch.herokuapp.com/</p></li>
</ul>
<p><strong>参考文献：</strong></p>
<p>官方教程：</p>
<p>https://devcenter.heroku.com/articles/getting-started-with-python</p>
<p>以及这些博客：</p>
<p>https://noviachen.github.io/posts/b4cb2e1c.html</p>
<p>https://wizardforcel.gitbooks.io/the-flask-mega-tutorial-2017-zh/content/docs/18.html</p>
<p>http://www.bjhee.com/flask-heroku.html</p>
<p>windows上部署参考（建议使用git bash）：https://caijialinxx.github.io/2018/07/25/deploy-on-heroku/</p>
<p>git bash创建并编辑文件参考：https://blog.csdn.net/qq_34289537/article/details/53994070</p>
<p>windows cmd常用命令参考：https://www.jianshu.com/p/80c3ac7bea8f</p>
<p>上传文件到github: https://www.jianshu.com/p/5227f837070b</p>
]]></content>
      <categories>
        <category>网站开发</category>
        <category>flask</category>
      </categories>
      <tags>
        <tag>flask</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title>flask干货总结</title>
    <url>/flask/</url>
    <content><![CDATA[<h1 id="flask">Flask</h1>
<blockquote>
<p>在一个Web应用里，客户端和服务器上的Flask程序的交互可以简单概括为以下几步：</p>
<p>1）用户在浏览器输入URL访问某个资源。</p>
<p>2）Flask接收用户请求并分析请求的URL。</p>
<p>3）为这个URL找到对应的处理函数。</p>
<p>4）执行函数并生成响应，返回给浏览器。</p>
<p>5）浏览器接收并解析响应，将信息显示在页面中。<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> <span id="more"></span></p>
</blockquote>
<h1 id="术语解释">术语解释</h1>
<ul>
<li>路由：作为动词时，含义是“按某路线发送”，即调用与请求URL对应的视图函数。</li>
<li>视图函数（view function）：处理请求并生成响应的函数。当用户访问URL时会触发视图函数，该函数可执行任意操作，比如从数据库中获取信息，获取请求信息，对用户输入的数据进行计算和处理等。最后，视图函数返回的值将作为响应的主体，一般来说就是HTML页面。</li>
<li>模板：包含程序页面的HTML文件。</li>
<li>静态文件：需要在HTML文件中加载的CSS和Java Script文件，以及图片、字体文件等资源文件。</li>
<li>模板文件存放在项目根目录中的templates文件夹中，静态文件存放在static文件夹下，这两个文件夹需要和包含程序实例的模块处于同一个目录下。</li>
<li>HTTP（Hypertext TransferProtocol，超文本传输协议）定义了服务器和客户端之间信息交流的格式和传递方式，它是万维网（World Wide Web）中数据交换的基础。</li>
<li>WSGI：将HTTP格式的请求数据转换成Flask程序能够使用的Python数据，并把python程序的响应经过WSGI转换生成HTTP响应。</li>
<li>URL中的查询字符串用来向指定的资源传递参数。查询字符串从问号?开始，以键值对的形式写出，多个键值对之间使用&amp;分隔。</li>
<li>这种浏览器与服务器之间交互的数据被称为报文（message），请求时浏览器发送的数据被称为请求报文（request message），而服务器返回的数据被称为响应报文（responsemessage）。</li>
<li>请求报文由请求的方法、URL、协议版本、首部字段（header）以及内容实体组成。</li>
<li>报文由报文首部和报文主体组成，两者由空行分隔，请求报文的主体一般为空。如果URL中包含查询字符串，或是提交了表单，那么报文主体将会是查询字符串和表单数据。</li>
<li>用来映射到数据库表的Python类通常被称为数据库模型（model），一个数据库模型类对应数据库中的一个表。所有的模型类都需要继承Flask-SQLAlchemy提供的db.Model基类。</li>
</ul>
<h1 id="架构">架构</h1>
<p>在MVC架构中，程序被分为三个组件：数据处理（Model）、用户界面（View）、交互逻辑（Controller）。</p>
<p>如果想要使用Flask来编写一个MVC架构的程序，那么视图函数可以作为控制器（Controller），视图（View）则是使用Jinja2渲染的HTML模板，而模型（Model）可以使用其他库来实现。</p>
<p>参考文献：</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><a href="https://book.douban.com/subject/30310340/">《Flask Web开发实战》</a><a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>网站开发</category>
        <category>flask</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title>Django网站开发全过程实录-1</title>
    <url>/django-1/</url>
    <content><![CDATA[<p>网站一般需要实现三种基本功能：<strong>连接数据库、处理用户请求、页面设计的删改</strong>。Django的优势在于将这些功能设计成独立的模块，形成一套web框架。利用Django框架开发网站，能让我们专注于编写应用程序而无需重新造轮子。 <span id="more"></span> Django 采用了 <strong>MVT 的软件设计模式</strong>，即<strong>模型</strong>（Model）、<strong>视图</strong>（View）和<strong>模板</strong>（Template）。这种设计模式的优势在于<strong>各个组件松散结合</strong>，每个APP应用都有明确的目的，并且可独立更改而不影响其它部分。如此，使得页面设计与业务逻辑互不影响。同时，Django是一套出色的<strong>动态内容管理系统</strong>，擅长动态提供数据库驱动的信息。</p>
<p>以下是我使用Django 3.1.7搭建网站过程的实录，力求完整、准确、无误地记录每个操作步骤与细节。</p>
<h2 id="环境搭建与工具安装"><strong>环境搭建与工具安装</strong></h2>
<blockquote>
<p><em>参考：</em><a href="https://stormsha.com/article/2026/"><em>https://stormsha.com/article/2026/</em></a></p>
</blockquote>
<p>我们需要在合适的目录内创建一个<strong>虚拟环境</strong>（用virtualenv, virtualenvwrapper皆可，参考<a href="https://blog.csdn.net/a200822146085/article/details/89048172">virtualenvwrapper的使用</a>），我给它取名为webdev。</p>
<p>在该虚拟环境，安装<strong>django</strong>和<strong>psycopg2</strong>工具包（用于管理PostgreSQL数据库）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install virtualenv, virtualenvwrapper-win</span><br><span class="line">mkvirtualenv webdev</span><br><span class="line">workon webdev</span><br><span class="line">pip install django</span><br><span class="line">pip install psycopg2</span><br><span class="line">pip list</span><br><span class="line">pip freeze</span><br><span class="line"></span><br><span class="line"># 如果需要退出或删除虚拟环境</span><br><span class="line">deactivate</span><br><span class="line">rmvirtualenv webdev</span><br></pre></td></tr></table></figure>
<p><strong>安装数据库：</strong></p>
<p>Django支持四种数据库：PostgreSQL、SQLite 3、MySQL、Oracle。</p>
<p>我选择PostgreSQL，它比MySQL更适合Django，Django的创建者如是说：</p>
<blockquote>
<p>如果您不受任何遗留系统的束缚，并且可以自由选择数据库后端，那么我们建议您使用PostgreSQL，它可以在成本、功能、速度和稳定性之间取得很好的平衡。（《 Django权威指南》第15页）</p>
</blockquote>
<p>PostgreSQL的安装步骤参考：https://www.runoob.com/postgresql/windows-install-postgresql.html</p>
<p>打开后设置语言为中文，然后关闭。</p>
<h2 id="创建项目project"><strong>创建项目（project）</strong></h2>
<p>下面在刚刚的虚拟环境webdev内创建一个项目mysite（你可以选择任意其他名字），项目是我们所建立的网站上所有应用程序的集合，并共用一套数据库配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd webdev</span><br><span class="line">django-admin startproject mysite</span><br></pre></td></tr></table></figure>
<p>我们看到新建了一个文件夹mysite及下面的子文件夹mysite/mysite：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysite&#x2F;</span><br><span class="line">    manage.py</span><br><span class="line">    mysite&#x2F;</span><br><span class="line">        __init__.py</span><br><span class="line">        settings.py</span><br><span class="line">        urls.py</span><br><span class="line">        asgi.py</span><br><span class="line">        wsgi.py</span><br></pre></td></tr></table></figure>
<p>我们可以把子文件夹mysite/mysite视为整个项目的配置，其中的settings.py和urls.py这两个文件是我们以后需要经常修改的。</p>
<h2 id="启动服务器server"><strong>启动服务器（server）</strong></h2>
<p>启动服务器，服务器会监测你的代码更新并自动加载，所以无须重启才看到效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd mysite</span><br><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>
<p>在settings.py内将语言改成中文，时区改为上海：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LANGUAGE_CODE &#x3D; &#39;zh-hans&#39;</span><br><span class="line"></span><br><span class="line">TIME_ZONE &#x3D; &#39;Asia&#x2F;Shanghai&#39;</span><br></pre></td></tr></table></figure>
<p>刷新浏览器看到中文页面。</p>
<p>我们可以指定服务器的端口和IP地址。比如，把地址设为自己的IP地址（例如192.168.1.110）或0.0.0.0，让联网的其他计算机可见：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py runserver 0.0.0.0:8000</span><br></pre></td></tr></table></figure>
<p>使用Windows的用户用ipconfig命令获取本地网络中的IP 地址，然后复制到setting.py中，比如我是这个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ALLOWED_HOSTS &#x3D; [&#39;192.168.1.110&#39;]</span><br></pre></td></tr></table></figure>
<p>于是，在其他电脑或手机浏览器打开 http://192.168.1.110:8000/ 就可以访问啦！完美！不过网站还在开发中，就不要随便开放共享啦~</p>
<h2 id="创建应用程序app"><strong>创建应用程序（APP）</strong></h2>
<p><strong>项目和应用的区分：</strong></p>
<ul>
<li><strong>应用</strong>是用于执行某项具体操作的程序，<strong>项目</strong>是特定网站的配置和应用程序的集合。</li>
<li><strong>多对多的关系</strong>：一个项目可以包含多个应用程序，一个应用程序可以用在多个项目中。</li>
</ul>
<p>应用放在任意路径都可以，但我们一般放在<strong>manage.py文件相同的目录</strong>中，与mysite子文件夹平行。在这里我创建一个成语检索的app，名为idiom：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py startapp idiom</span><br></pre></td></tr></table></figure>
<p>看看这个应用程序下有哪些文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">idiom&#x2F;</span><br><span class="line">    __init__.py</span><br><span class="line">    admin.py</span><br><span class="line">    apps.py</span><br><span class="line">    migrations&#x2F;</span><br><span class="line">        __init__.py</span><br><span class="line">    models.py</span><br><span class="line">    tests.py</span><br><span class="line">    views.py</span><br></pre></td></tr></table></figure>
<h2 id="编写视图views"><strong>编写视图（views）</strong></h2>
<p>下面为这个应用程序idiom添砖加瓦，分为三个步骤：</p>
<ol type="1">
<li>创建视图函数</li>
<li>将视图函数映射到APP的urls</li>
<li>将APP中的urls连入网站的根urls</li>
</ol>
<p>这样看逻辑可能更清晰：视图函数 --&gt; APP的urls --&gt; 网站的urls</p>
<h2 id="创建视图函数"><strong>创建视图函数</strong></h2>
<p>打开文件idiom/views.py ，加入以下Python代码，<strong>创建index视图函数</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.http import HttpResponse</span><br><span class="line"></span><br><span class="line">def index(request):</span><br><span class="line">    return HttpResponse(&quot;Hello, world. You&#39;re at the idiom index.&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="映射到app的urls"><strong>映射到APP的urls</strong></h2>
<p>要调用该视图，我们要将其映射到URL，为此，我们需要添加一个URL配置（URLconf）。<strong>URLconf</strong>相当于网站的目录，也就是<strong>URL模式与视图函数之间的映射表</strong>。</p>
<p>我们在idiom应用的目录下创建一个名为urls.py的文件，windows操作如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type nul&gt;urls.py</span><br></pre></td></tr></table></figure>
<p>看看现在的应用目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">idiom&#x2F;</span><br><span class="line">    __init__.py</span><br><span class="line">    admin.py</span><br><span class="line">    apps.py</span><br><span class="line">    migrations&#x2F;</span><br><span class="line">        __init__.py</span><br><span class="line">    models.py</span><br><span class="line">    tests.py</span><br><span class="line">    urls.py</span><br><span class="line">    views.py</span><br></pre></td></tr></table></figure>
<p>然后在idiom/urls.py这个空文件中加入以下代码，将index视图映射到APP的url模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.urls import path</span><br><span class="line"></span><br><span class="line">from . import views</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    path(&#39;&#39;, views.index, name&#x3D;&#39;index&#39;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="连入网站的urls"><strong>连入网站的urls</strong></h2>
<p>下一步是将根URLconf（mysite/urls.py）指向idiom.urls模块，使得网站域名连接到app的url。我们打开mysite/urls.py，修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.contrib import admin</span><br><span class="line">from django.urls import include, path</span><br><span class="line"></span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    path(&#39;idiom&#x2F;&#39;, include(&#39;idiom.urls&#39;)),</span><br><span class="line">    path(&#39;admin&#x2F;&#39;, admin.site.urls),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>该include()功能允许引用其他URLconf，这样我们就将刚刚创建的index视图连接到了网站的URLconf。</p>
<p>也就是说，目前我们可以打开两个网址：</p>
<p><a href="http://127.0.0.1:8000/idiom/">http://example.com/idiom/</a></p>
<p><a href="http://127.0.0.1:8000/idiom/">http://example.com/admin/</a></p>
<p>注意idiom和admin在引用URL模式时的区别：除了admin.site.urls（用于管理后台），我们引用其他URL模式时，都应使用include()。</p>
<p>最后，验证下是否正常运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py runserver</span><br></pre></td></tr></table></figure>
<p>打开http://127.0.0.1:8000/idiom/ ，可以看到 Hello, world. You're at the idiom index. 这行文字。</p>
<h2 id="urlconf的工作原理"><strong>URLconf的工作原理</strong></h2>
<p>Django允许我们根据需要设计每个应用程序的URL，通过创建<strong>URLconf</strong>（URL配置）。</p>
<p>在 idiom和mysite文件夹下的urls.py中，我们都使用了<a href="https://docs.djangoproject.com/en/3.1/ref/urls/#django.urls.path">path()</a>函数，这个函数有两个必需的参数 route和view。</p>
<p>path（<em>route</em>，<em>view</em>，<em>kwargs = None</em>，<em>name = None</em>）</p>
<ul>
<li>route是包含URL模式的字符串，比如目前我们有idiom/和admin/。在处理请求时，Django从第一个模式开始，沿列表的顺序，将请求的URL（域名后的部分）与每个模式进行比较，直到找到匹配的URL。这个字符串支持用尖括号匹配和捕获URL的一部分并将其作为关键字参数发送到视图，</li>
<li>view就是指定的视图函数，也可以是一个<a href="https://docs.djangoproject.com/en/3.1/ref/urls/#django.urls.include">django.urls.include()</a>。kwargs参数允许我们将其他参数传递给视图函数。</li>
<li>name不是必须的，但是命名URL的好处是便于在Django中的其他地方（尤其是在模板内部）明确地引用它。</li>
</ul>
<p>参考：<a href="https://docs.djangoproject.com/en/3.1/ref/urls/#django.urls.path">django.urls functions for use in URLconfs</a></p>
]]></content>
      <categories>
        <category>网站开发</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>django</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>《自然语言处理综论》第14章-依存分析（中）</title>
    <url>/dependency-parsing-2/</url>
    <content><![CDATA[<h1 id="基于转换的依存分析">14.4 基于转换的依存分析</h1>
<p>我们的第一个依存分析方法是由一种基于堆栈的方法启发的，这种方法被称为shift-reduce parsing，最初是为分析程序语言而开发的(Aho and Ullman, 1972)。这个经典的方法简单而优雅，采用了一个上下文无关语法、一个堆栈和一个待解析的标记列表。输入的标记被连续地移动到堆栈上，堆栈的前两个元素与语法中的右侧规则进行匹配；当发现匹配时，匹配的元素在堆栈上被匹配的规则左侧的非终端替换（还原）。在将这种方法改编为依存性解析时，我们放弃了对语法的明确使用，并改变了reduce操作，使其不是在解析树上添加一个非终端，而是引入了一个词与其头部之间的依存关系。更具体地说，reduce操作被两种可能的操作所取代：在堆栈顶部的词和它下面的词之间断言一个词头依存关系，或者反之。图14.5说明了这种解析器的基本操作。 配置 在基于过渡的解析中，一个关键的元素是配置的概念，它由一个堆栈、一个词或标记的输入缓冲区和一组代表依存树的关系组成。在这个框架下，解析过程由一个通过可能配置空间的过渡序列组成。这个过程的目标是找到一个最终的配置，在这个配置中，所有的词都已经被计算在内，并且已经合成了一个合适的依存树。 为了实现这样的搜索，我们将定义一组过渡运算符，当它们应用于一个配置时，会产生新的配置。考虑到这个设置，我们可以将解析器的操作看作是在配置空间中搜索从起始状态到目标状态的过渡序列。在这个过程的开始，我们创建一个初始配置，其中堆栈包含ROOT节点，t</p>
]]></content>
      <categories>
        <category>自然语言处理</category>
        <category>依存分析</category>
      </categories>
      <tags>
        <tag>nlp</tag>
        <tag>dependency</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
