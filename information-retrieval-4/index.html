<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon-16x16-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <meta name="baidu-site-verification" content="code-FTCajqaAZT" />

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"nlpcourse.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","width":240,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="11.1.1 知识库  (knowledge base) 本章旨在教会你的机器人理解它所阅读的内容，并将知识存储在一个灵活的数据结构中，即将信息记录在一个知识库中，用于后期查询。除了识别文本中的数字和日期等简单任务之外，机器人还要提取更多关于世界的一般信息。 例如，它能够从自然语言文档中（比如维基百科）学习这句话：  In 1983, Stanislav Petrov, a lieutenant">
<meta property="og:type" content="article">
<meta property="og:title" content="信息抽取">
<meta property="og:url" content="http://nlpcourse.cn/information-retrieval-4/index.html">
<meta property="og:site_name" content="鸽婆打字机">
<meta property="og:description" content="11.1.1 知识库  (knowledge base) 本章旨在教会你的机器人理解它所阅读的内容，并将知识存储在一个灵活的数据结构中，即将信息记录在一个知识库中，用于后期查询。除了识别文本中的数字和日期等简单任务之外，机器人还要提取更多关于世界的一般信息。 例如，它能够从自然语言文档中（比如维基百科）学习这句话：  In 1983, Stanislav Petrov, a lieutenant">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/04/13/NoW1JAQhvMOaCTX.png">
<meta property="og:image" content="https://i.loli.net/2021/04/13/oF3AcQ9CBVrps1X.png">
<meta property="article:published_time" content="2021-03-18T01:46:05.452Z">
<meta property="article:modified_time" content="2021-04-13T15:29:55.751Z">
<meta property="article:author" content="鸽鸽">
<meta property="article:tag" content="nlp">
<meta property="article:tag" content="IR">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/04/13/NoW1JAQhvMOaCTX.png">

<link rel="canonical" href="http://nlpcourse.cn/information-retrieval-4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>信息抽取 | 鸽婆打字机</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">鸽婆打字机</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">自然语言处理笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">31</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">29</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">50</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://nlpcourse.cn/information-retrieval-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="鸽鸽">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="鸽婆打字机">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          信息抽取
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-03-18 09:46:05" itemprop="dateCreated datePublished" datetime="2021-03-18T09:46:05+08:00">2021-03-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-13 23:29:55" itemprop="dateModified" datetime="2021-04-13T23:29:55+08:00">2021-04-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">自然语言处理</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%96/" itemprop="url" rel="index"><span itemprop="name">信息抽取</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>18k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>17 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="11-1-1-知识库-knowledge-base">11.1.1 知识库  (knowledge base)</h3>
<p>本章旨在教会你的机器人理解它所阅读的内容，并将知识存储在一个灵活的数据结构中，即将信息记录在一个知识库中，用于后期查询。除了识别文本中的数字和日期等简单任务之外，机器人还要提取更多关于世界的一般信息。</p>
<p>例如，它能够从自然语言文档中（比如维基百科）学习这句话：</p>
<blockquote>
<p>In 1983, Stanislav Petrov, a lieutenant colonel of the Soviet Air Defense Forces,  saved the world from nuclear war.</p>
<p>1983年，斯坦尼斯拉夫·彼得罗夫，苏联防空部队的一名中校从核战争中拯救了世界。</p>
</blockquote>
<p>如果你在历史课上读完或听完这样的内容后做笔记，你可能会对事情进行解读，并在大脑中建立概念或词语之间的联系。你可能会把它还原成一个知识，那个你“从中得到的东西”。你希望你的机器人也能做同样的事情， “记下”它所学到的任何东西，比如斯坦尼斯洛夫·彼得罗夫是一名中校的事实或知识。</p>
<p>它可以存储在一个类似这样的数据结构中：</p>
<blockquote>
<p>(‘Stanislav Petrov’, ‘is-a’, ‘lieutenant colonel’)</p>
</blockquote>
<p>这是知识图谱或知识库中两个<u>命名实体节点</u>(‘Stanislav Petrov’和’lieutenant colonel’)和它们之间的<u>关系</u>或连接(‘is a’)的例子。当这样的关系以符合知识图谱的<u>RDF标准</u>（关系描述格式）的形式存储时，它被称为<u>RDF三元模型(triplet)</u>。历史上，这些RDF triplet存储在XML文件中，但也可以存储在任何文件格式或数据库中，这些文件格式或数据库以 <u>(subject, relation, object)</u> 的形式保存，这些三元组的集合就是一个知识图谱。这有时也被语言学家称为<u>本体</u>（ontology），因为它存储的是关于词的结构化信息。但当图谱的目的是为了表示关于世界的事实而不仅仅是单词时，它就被称为<u>知识图谱</u>或<u>知识库</u>。</p>
<p>图11.1是你想从这样的句子中提取的知识图谱的图形表示。 图11.1顶部的“is-a”关系代表了一个不能直接从斯坦尼斯拉夫的陈述中提取的事实。但从一个军事组织成员的头衔是军衔这一事实可以推断出，“中校”是一个军衔。这种从知识图谱中推导出事实的逻辑操作叫做<u>知识推理</u>。也可以称为查询知识库，类似于查询关系型数据库。</p>
<img src="https://i.loli.net/2021/04/13/NoW1JAQhvMOaCTX.png"/>
<p>对于斯坦尼斯洛夫的军衔这一特殊推断或查询，你的知识图谱必须已经包含了关于军队和军衔的事实。也许你现在可以看到知识库是如何帮助机器理解一个语句的。如果没有这个知识基础，像这样简单的语句中的许多事实都会让你的聊天机器人“摸不着头脑”。你甚至可以说，关于职业等级的问题对于一个只知道如何根据随机分配的主题对文件进行分类的机器人来说，是“超乎寻常的&quot;。如果你曾经与一个不懂“哪条路是向上的“的聊天机器人进行过互动，你就会明白。在人工智能研究中，最令人生畏的挑战之一是如何编译和高效查询常识性知识的知识图谱。</p>
<p>**机器很难找到常识性知识的语料库来阅读和学习。**没有常识性知识的维基百科文章存在，你的机器就无法对其进行信息抽取。而有些知识是本能，是硬编码在我们的DNA中的，事物和人之间存在各种事实关系，比如“kindof&quot;、“is-used-for”、“has-a”、“is-famous-for”、“was-born“和“has-profession”。</p>
<p>卡耐基梅隆大学永无止境的语言学习机器人NELL，几乎完全专注于提取“kind-of”关系信息的任务。大多数知识库都会对定义这些关系的字符串进行归一化处理，这样“kind of”和“type of”就会被分配一个归一化的字符串或ID来表示这个特定的关系。而有些知识库也会对知识库中代表obejct的名词进行解析。所以“Stanislav Petrov”这个bigram可能会被分配一个特定的ID。“Stanislav Petrov”的同义词，比如“S. Petrov”和“Lt Col Petrov”，也会被分配给同一个ID，如果NLP管道怀疑它们指的是同一个人。 知识库可以用来构建一种实用型的聊天机器人，称为问答系统（QA系统）。客服聊天机器人，包括大学TA机器人，几乎完全依靠知识库来生成他们的回答。问答系统对于帮助人类发现事实信息非常有用，它可以让人类的大脑自由地做自己擅长的事情，比如试图从这些事实中归纳总结。<strong>人类不善于准确地记住事实，但善于发现这些事实之间的联系和模式，这是机器尚未掌握的。</strong></p>
<h3 id="11-1-2-信息抽取">11.1.2 信息抽取</h3>
<p>所以你已经了解到“信息抽取“是将非结构化文本转换为存储在知识库或知识图谱中的结构化信息。信息抽取是被称为自然语言理解（NLU）的研究领域的一部分，尽管这个术语经常与自然语言处理同义使用。  信息抽取和NLU是一种不同于你在研究数据科学时可能想到的学习。它不仅仅是无监督的学习，甚至连“模型“本身，即关于世界如何运作的逻辑，都可以在没有人类干预的情况下组成。与其说是给机器钓鱼（事实），不如说是教它如何钓鱼（提取信息）。尽管如此，机器学习技术还是经常被用来训练信息抽取器。</p>
<h3 id="11-2-2-信息抽取作为ML特征提取">11.2.2 信息抽取作为ML特征提取</h3>
<p>模式匹配（和正则表达式）仍然是信息抽取的最先进的方法。即使使用机器学习方法来处理自然语言，你也需要进行特征工程。你需要创建词袋或词嵌入，以尝试将自然语言文本中近乎无限的意义可能性减少到机器可以轻松处理的向量中。信息抽取只是机器学习从非结构化自然语言数据中提取特征的另一种形式，比如创建一个词袋，或者在这个词袋上做PCA。而这些模式和特征即使在最先进的自然语言机器学习管道中仍然被采用，比如谷歌的Assistant、Siri、亚马逊Alexa和其他最先进的机器人。</p>
<p>信息抽取可以事先完成，以填充事实的知识库。或者，当聊天机器人被问到一个问题或搜索引擎被查询时，可以按需找到所需的语句和信息。当提前建立知识库时，可以优化数据结构，以便在更大的知识领域内进行更快的查询。预先构建的知识库可以让聊天机器人快速响应关于更广泛信息的问题。如果在聊天机器人被查询时实时检索信息，这通常被称为“搜索&quot;。</p>
<p>Google和其他搜索引擎结合了这两种技术，查询知识库（knowledge base），如果没有找到必要的事实，就回落到文本搜索。你在学校里学到的许多自然语言语法规则可以被编码在正式的语法中，设计成对代表语言部分的单词或符号进行操作。而英语语言可以被认为是构成语言的单词和语法规则，或者你也可以把它看成是你可以说的所有可能的事情的集合，这些事情会被英语语言使用者认可为有效的语句。 而这就引出了<u>形式化语法</u>和<u>有限状态机</u>的另一个特点，它将在NLP中派上用场。</p>
<p>任何形式化语法都可以被机器以两种方式使用：</p>
<ul>
<li>
<p>识别与该语法相匹配的内容</p>
</li>
<li>
<p>生成新的符号序列</p>
</li>
</ul>
<p>你不仅可以使用模式（正则表达式）从自然语言中提取信息，还可以在聊天机器人中使用它们，让它“说“出与该模式相匹配的东西！我们将向你展示如何用有限状态机来实现这一点。我们在这里向你展示如何使用一个名为rstr4的包来实现这个功能，用于你的一些信息抽取模式。 这种形式化语法和有限状态机的模式匹配方法还有其他一些很棒的特性。</p>
<p>一个真正的有限状态机可以保证总是在有限时间内运行（停止）。它将始终告诉你是否在你的字符串中找到了匹配。它永远不会陷入永久循环…只要你不使用正则表达式引擎的一些高级功能，这些功能允许你“欺骗“并将循环纳入你的有限状态机。 所以，你要坚持使用不需要这些“回看“或“前瞻“作弊的正则表达式。你将确保你的正则表达式匹配器会处理每个字符，并且只有当它匹配时才会前进到下一个字符–有点像一个严格的列车员在座位上走动检查车票。如果你没有，列车员就会停下来，并宣布有问题，不匹配，他拒绝继续前进，或查看你的前面或后面，直到他解决这个问题。火车上的乘客没有“走回头路“或“重来&quot;，也没有严格的正则表达式。</p>
<h2 id="11-3-值得提取的信息">11.3 值得提取的信息</h2>
<p>一些关键的定量信息值得“手工制作”正则表达式的努力：</p>
<blockquote>
<p>GPS位置｜日期｜价格｜数字</p>
</blockquote>
<p>其他重要的自然语言信息需要比正则表达式更复杂的模式：</p>
<blockquote>
<p>问题触发词｜问题目标词｜命名实体</p>
</blockquote>
<h3 id="11-3-1-提取GPS位置">11.3.1 提取GPS位置</h3>
<p>GPS位置是典型的数字数据，你需要使用正则表达式从文本中提取。GPS位置是以一对经纬度的数字值来表示的。它们有时还包括第三个数字，即海拔高度，或海平面以上的高度，但你现在将忽略它。我们只提取十进制的经纬度对，用度数表示。这将适用于许多谷歌地图的URL。虽然URL在技术上不是自然语言，但它们通常是非结构化文本数据的一部分，你想提取这一点信息，这样你的聊天机器人就可以知道地方以及事物。 让我们使用之前例子中的十进制数字模式，但让我们更具限制性，确保该值在纬度（+/- 90度）和经度（+/- 180度）的有效范围内。你不能比北极（+90度）更北，也不能比南极（-90度）更南。而如果你从英国格林威治向东航行180度（+180度经度），你就会到达日期线，在那里你也是从格林威治向西180度（-180度）。请看下面的列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lat = <span class="string">r&#x27;([-]?[0-9]?[0-9][.][0-9]&#123;2,10&#125;)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lon = <span class="string">r&#x27;([-]?1?[0-9]?[0-9][.][0-9]&#123;2,10&#125;)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sep = <span class="string">r&#x27;[,/ ]&#123;1,3&#125;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re_gps = re.<span class="built_in">compile</span>(lat + sep + lon)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re_gps.findall(<span class="string">&#x27;http://...maps/@34.0551066,-118.2496763...&#x27;</span>)</span><br><span class="line">[(<span class="number">34.0551066</span>, -<span class="number">118.2496763</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re_gps.findall(<span class="string">&quot;https://www.openstreetmap.org/#map=10/5.9666/116.0566&quot;</span>)</span><br><span class="line">[(<span class="string">&#x27;5.9666&#x27;</span>, <span class="string">&#x27;116.0566&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re_gps.findall(<span class="string">&quot;Zig Zag Cafe is at 45.344, -121.9431 on my GPS.&quot;</span>)</span><br><span class="line">[(<span class="string">&#x27;45.3440&#x27;</span>, <span class="string">&#x27;-121.9431&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<p>数字数据很容易提取，特别是如果数字是机器可读字符串的一部分。URL和其他机器可读的字符串将经纬度等数字以可预测的顺序、格式和单位排列，以方便我们。这种模式仍然会接受一些不属于这个世界的经纬度值，但它可以满足你从OpenStreetMap等地图网络应用中复制的大多数URL的要求。 但是日期呢？正则表达式对日期有用吗？如果你想让你的日期提取器能在欧洲和美国工作，那该怎么办，因为那里的日/月顺序经常是相反的。</p>
<h3 id="11-3-2-提取日期">11.3.2 提取日期</h3>
<p>日期比 GPS 坐标更难提取。日期是一种比较自然的语言，类似的事情有不同的方言来表达。在美国，2017年的圣诞节是“12/25/17&quot;。在欧洲，2017年的圣诞节是“25/12/17&quot;。你可以检查你的用户的所在地，并假设他们和他们所在地区的其他人一样写日期。但这个假设可能是错误的。 因此，大多数日期和时间提取器都会尝试使用这两种日/月顺序，并检查以确保这是一个有效的日期。当我们读到这样的日期时，人脑就是这样工作的。即使你是一个美式英语的人，你在圣诞节前后在布鲁塞尔，你也可能会认出“25/12/17“是一个节日，因为一年只有12个月。</p>
<p>**这种在计算机编程中行之有效的“鸭子打字“ (duck-typing) 法<a target="_blank" rel="noopener" href="https://www.pythonf.cn/read/129220">^1</a>也可以用于自然语言。如果它看起来像一只鸭子，行为又像鸭子，那它可能就是一只鸭子。**如果它看起来像个日期，行为又像个日期，那可能就是个日期。你会把这种“先试后买“的方法也用在其他自然语言处理任务上。你会尝试一堆选项，然后接受一个有效的选项。你会尝试你的提取器或生成器，然后你会在上面运行一个验证器，看看它是否合理。 对于聊天机器人来说，这是一个特别强大的方法，允许你结合多个自然语言生成器的优点。在第10章中，你使用LSTMs生成了一些聊天机器人的回复。为了改善用户体验，你可以生成很多回复，然后选择拼写、语法和情感最好的那个。我们将在第12章中详细讨论这个问题。请看下面的列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>us = <span class="string">r&#x27;((([01]?\d)[-/]([0123]?\d))([-/]([0123]\d)\d\d)?)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mdy = re.findall(us, <span class="string">&#x27;Santa came 12/25/2017. An elf appeared 12/12.&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mdy</span><br><span class="line">[(<span class="string">&#x27;12/25/2017&#x27;</span>, <span class="string">&#x27;12/25&#x27;</span>, <span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;25&#x27;</span>, <span class="string">&#x27;/2017&#x27;</span>, <span class="string">&#x27;20&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;12/12&#x27;</span>, <span class="string">&#x27;12/12&#x27;</span>, <span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;12&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<p>列表理解可以用来为提取的数据提供一点结构，方法是将月份、日期和年份转换为整数，并用有意义的名称标记这些数字信息，如下面的列表所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dates = [&#123;<span class="string">&#x27;mdy&#x27;</span>: x[<span class="number">0</span>], <span class="string">&#x27;my&#x27;</span>: x[<span class="number">1</span>], <span class="string">&#x27;m&#x27;</span>: <span class="built_in">int</span>(x[<span class="number">2</span>]), <span class="string">&#x27;d&#x27;</span>: <span class="built_in">int</span>(x[<span class="number">3</span>]),</span><br><span class="line"><span class="meta">... </span><span class="string">&#x27;y&#x27;</span>: <span class="built_in">int</span>(x[<span class="number">4</span>].lstrip(<span class="string">&#x27;/&#x27;</span>) <span class="keyword">or</span> <span class="number">0</span>), <span class="string">&#x27;c&#x27;</span>: <span class="built_in">int</span>(x[<span class="number">5</span>] <span class="keyword">or</span> <span class="number">0</span>)&#125; <span class="keyword">for</span> x <span class="keyword">in</span> mdy]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dates</span><br><span class="line">[&#123;<span class="string">&#x27;mdy&#x27;</span>: <span class="string">&#x27;12/25/2017&#x27;</span>, <span class="string">&#x27;my&#x27;</span>: <span class="string">&#x27;12/25&#x27;</span>, <span class="string">&#x27;m&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">25</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2017</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">20</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;mdy&#x27;</span>: <span class="string">&#x27;12/12&#x27;</span>, <span class="string">&#x27;my&#x27;</span>: <span class="string">&#x27;12/12&#x27;</span>, <span class="string">&#x27;m&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">0</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>即使对于这些简单的日期，也不可能设计出一个能够解决第二个日期“12/12”中所有歧义的regex。在日期的语言中，有一些含糊不清的地方，只有人类能够利用圣诞节等知识和文本作者的意图来猜测解决。</p>
<p>比如“12/12“可能意味着：</p>
<blockquote>
<p>December 12th, 2017—month/day in the estimated year based on anaphora resolution</p>
<p>December 12th, 2018—month/day in the current year at time of publishing</p>
<p>December 2012—month/year in the year 2012</p>
</blockquote>
<p>因为在美国日期和我们的regex中，month/day在年份之前，&quot;12/12“被假定为未知年份的12月12日。你可以使用内存中的结构化数据中的上下文来填充任何缺失的数字字段，如下面的列表所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, d <span class="keyword">in</span> <span class="built_in">enumerate</span>(dates):</span><br><span class="line"><span class="meta">... </span><span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line"><span class="meta">... </span><span class="keyword">if</span> <span class="keyword">not</span> v:</span><br><span class="line"><span class="meta">... </span>d[k] = dates[<span class="built_in">max</span>(i - <span class="number">1</span>, <span class="number">0</span>)][k]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dates</span><br><span class="line">[&#123;<span class="string">&#x27;mdy&#x27;</span>: <span class="string">&#x27;12/25/2017&#x27;</span>, <span class="string">&#x27;my&#x27;</span>: <span class="string">&#x27;12/25&#x27;</span>, <span class="string">&#x27;m&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">25</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2017</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">20</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;mdy&#x27;</span>: <span class="string">&#x27;12/12&#x27;</span>, <span class="string">&#x27;my&#x27;</span>: <span class="string">&#x27;12/12&#x27;</span>, <span class="string">&#x27;m&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">12</span>, <span class="string">&#x27;y&#x27;</span>: <span class="number">2017</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">20</span>&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> date</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetimes = [date(d[<span class="string">&#x27;y&#x27;</span>], d[<span class="string">&#x27;m&#x27;</span>], d[<span class="string">&#x27;d&#x27;</span>]) <span class="keyword">for</span> d <span class="keyword">in</span> dates]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetimes</span><br><span class="line">[datetime.date(<span class="number">2017</span>, <span class="number">12</span>, <span class="number">25</span>), datetime.date(<span class="number">2017</span>, <span class="number">12</span>, <span class="number">12</span>)]</span><br></pre></td></tr></table></figure>
<p>这是一种从自然语言文本中提取日期信息的基本但相当健壮的方法。要把它变成一个生产型的日期提取器，剩下的主要任务就是添加一些适合你的应用的异常捕获和上下文维护。如果你通过拉取请求将其添加到nlpia包(<a target="_blank" rel="noopener" href="http://github.com/">http://github.com/</a> totalgood/nlpia)中，我相信你的读者朋友们会很感激。而如果你为时间添加了一些提取器，好吧，那你就是相当的英雄了。 一些手工制作的逻辑有机会处理几个月甚至几天的边缘情况和自然语言名称。但是再复杂也无法解决“12/11“这个日期的歧义。这可能是12月11日，无论你在哪一年读到或听到它11月12日，如果你在伦敦或塔斯马尼亚州朗塞斯顿（一个联邦领土）听到它2011年12月，如果你在美国报纸上读到它2012年11月，如果你在欧盟报纸上读到它有些自然语言的歧义是无法解决的，即使是人脑。但是，让我们确保你的日期提取器可以通过在你的regex中颠倒月份和日期来处理欧洲的日/月顺序。请看下面的列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>eu = <span class="string">r&#x27;((([0123]?\d)[-/]([01]?\d))([-/]([0123]\d)?\d\d)?)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dmy = re.findall(eu, <span class="string">&#x27;Alan Mathison Turing OBE FRS (23/6/1912-7/6/1954) \</span></span><br><span class="line"><span class="string">... was an English computer scientist.&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dmy</span><br><span class="line">[(<span class="string">&#x27;23/6/1912&#x27;</span>, <span class="string">&#x27;23/6&#x27;</span>, <span class="string">&#x27;23&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;/1912&#x27;</span>, <span class="string">&#x27;19&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;7/6/1954&#x27;</span>, <span class="string">&#x27;7/6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;/1954&#x27;</span>, <span class="string">&#x27;19&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dmy = re.findall(eu, <span class="string">&#x27;Alan Mathison Turing OBE FRS (23/6/12-7/6/54) \</span></span><br><span class="line"><span class="string">... was an English computer scientist.&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dmy</span><br><span class="line">[(<span class="string">&#x27;23/6/12&#x27;</span>, <span class="string">&#x27;23/6&#x27;</span>, <span class="string">&#x27;23&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;/12&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;7/6/54&#x27;</span>, <span class="string">&#x27;7/6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;/54&#x27;</span>, <span class="string">&#x27;&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<p>这个正则表达式正确地从维基百科的摘录中提取了图灵的生卒日期。但我作弊了，我把“6月”这个月份转换成了数字6，然后才在维基百科的那句话上测试正则表达式。所以这不是一个现实的例子。而且如果不指定世纪的话，你对年份的解析还是会有一些歧义的。54年是指1954年还是指2054年？你希望你的聊天机器人能够从未经修改的维基百科文章中提取日期，这样它就可以阅读名人的资料，学习导入日期。为了让您的正则表达式能够在更多的自然语言日期上发挥作用，例如维基百科文章中的日期，您需要在您的日期提取正则表达式中添加诸如“June&quot;（及其所有缩写）这样的单词。 你不需要任何特殊符号来表示单词（按顺序排列的字符）。你可以在正则表达式中完全按照你希望它们在输入中的拼写来输入，包括大写。你所要做的就是在它们之间的正则表达式中加上一个OR符号(|)。你需要确保它可以处理美国的月/日顺序以及欧洲的顺序。你将把这两种可供选择的日期“拼法“添加到你的正则表达式中，在它们之间加上一个“大“的 OR (|)，作为正则表达式中决策树的分叉。 让我们使用一些命名组来帮助你识别年份，比如&quot;‘84’&quot;是1984，&quot;08“是2008。而且让我们尝试更精确地匹配4位数的年份，只匹配未来到2399年的年份和过去到0.6年的年份，请看下面的列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>yr_19xx = (</span><br><span class="line"><span class="meta">... </span><span class="string">r&#x27;\b(?P&lt;yr_19xx&gt;&#x27;</span> +</span><br><span class="line"><span class="meta">... </span><span class="string">&#x27;|&#x27;</span>.join(<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>, <span class="number">100</span>)) +</span><br><span class="line"><span class="meta">... </span><span class="string">r&#x27;)\b&#x27;</span></span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>yr_20xx = (</span><br><span class="line"><span class="meta">... </span><span class="string">r&#x27;\b(?P&lt;yr_20xx&gt;&#x27;</span> +</span><br><span class="line"><span class="meta">... </span><span class="string">&#x27;|&#x27;</span>.join(<span class="string">&#x27;&#123;:02d&#125;&#x27;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)) + <span class="string">&#x27;|&#x27;</span> +</span><br><span class="line"><span class="meta">... </span><span class="string">&#x27;|&#x27;</span>.join(<span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>, <span class="number">30</span>)) +</span><br><span class="line"><span class="meta">... </span><span class="string">r&#x27;)\b&#x27;</span></span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>yr_cent = <span class="string">r&#x27;\b(?P&lt;yr_cent&gt;&#x27;</span> + <span class="string">&#x27;|&#x27;</span>.join(</span><br><span class="line"><span class="meta">... </span><span class="string">&#x27;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">40</span>)) + <span class="string">r&#x27;)&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>yr_ccxx = <span class="string">r&#x27;(?P&lt;yr_ccxx&gt;&#x27;</span> + <span class="string">&#x27;|&#x27;</span>.join(</span><br><span class="line"><span class="meta">... </span><span class="string">&#x27;&#123;:02d&#125;&#x27;</span>.<span class="built_in">format</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">100</span>)) + <span class="string">r&#x27;)\b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>yr_xxxx = <span class="string">r&#x27;\b(?P&lt;yr_xxxx&gt;(&#x27;</span> + yr_cent + <span class="string">&#x27;)(&#x27;</span> + yr_ccxx + <span class="string">r&#x27;))\b&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>yr = (</span><br><span class="line"><span class="meta">... </span><span class="string">r&#x27;\b(?P&lt;yr&gt;&#x27;</span> +</span><br><span class="line"><span class="meta">... </span>yr_19xx + <span class="string">&#x27;|&#x27;</span> + yr_20xx + <span class="string">&#x27;|&#x27;</span> + yr_xxxx +</span><br><span class="line"><span class="meta">... </span><span class="string">r&#x27;)\b&#x27;</span></span><br><span class="line"><span class="meta">... </span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>groups = <span class="built_in">list</span>(re.finditer(</span><br><span class="line"><span class="meta">... </span>yr,“<span class="number">0</span>, <span class="number">2000</span>, 01, <span class="string">&#x27;08, 99, 1984, 2030/1970 85 47 `66&quot;))</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; full_years = [g[&#x27;</span>y<span class="string">r&#x27;] for g in groups]</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; full_years</span></span><br><span class="line"><span class="string">[&#x27;</span><span class="number">2000</span><span class="string">&#x27;, &#x27;</span>01<span class="string">&#x27;, &#x27;</span>08<span class="string">&#x27;, &#x27;</span><span class="number">99</span><span class="string">&#x27;, &#x27;</span><span class="number">1984</span><span class="string">&#x27;, &#x27;</span><span class="number">2030</span><span class="string">&#x27;, &#x27;</span><span class="number">1970</span><span class="string">&#x27;, &#x27;</span><span class="number">85</span><span class="string">&#x27;, &#x27;</span><span class="number">47</span><span class="string">&#x27;, &#x27;</span><span class="number">66</span><span class="string">&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>哇！这可真够费劲的。这是一个很大的工作，只是为了在regex中而不是在Python中处理一些简单的年份规则。别担心，有一些包可以用来识别常见的日期格式。它们更精确 (更少的错误匹配) 和更通用 (更少的失误)。所以，你不需要自己能够编写复杂的正则表达式，比如这样。这个例子只是给你提供了一个模式，以备将来你需要使用正则表达式提取某种特定的数字。货币值和 IP 地址是一些例子，在这些例子中，一个更复杂的正则表达式（带有命名组）可能会派上用场。 让我们完成你的提取日期的正则表达式，为维基百科上的日期添加月份名称的模式，比如图灵生日中的“June“或“Jun&quot;，如下面的列表所示。你能看到如何将这些正则表达式组合成一个更大的可以处理欧盟和美国日期格式的正则表达式吗？一个复杂的问题是，你不能为一个组重复使用相同的名称（正则表达式的括号部分）。所以你不能在月份和年份的命名正则表达式的美国和欧盟排序之间放一个OR。而且你需要在日、月、年之间包含一些可选的分隔符的模式。最后，你需要验证这些日期，看看它们是否可以变成有效的Python日期时间对象，如下面的列表所示。想想像Python-dateutil和datefinder这样的包是如何解决歧义和处理更多“自然“语言的日期，比如“今天“和“下周一&quot;。如果你认为你能比这些包做得更好，就给他们发个拉请求吧!  如果你只是想要一个最先进的日期提取器，统计（机器学习）方法会让你更快地达到目的。Stanford Core NLP SUTime库(https:// <a target="_blank" rel="noopener" href="http://nlp.stanford.edu/software/sutime.html">nlp.stanford.edu/software/sutime.html</a>)和Google的dateutil.parser.parse是最先进的。</p>
<h2 id="11-4-提取关系（relation）">11.4 提取关系（relation）</h2>
<p>到目前为止，你只研究了提取棘手的名词实例，如日期和GPS经纬度值。而且你主要是处理数字模式。现在是时候解决从自然语言中提取知识这个更难的问题了。</p>
<p>你想让你的机器人从阅读知识百科全书（如维基百科）中了解关于世界的事实。你希望它能够将这些日期和GPS坐标与它所阅读的实体联系起来。你的大脑可以从维基百科的这句话中提取什么知识呢？</p>
<blockquote>
<p>On March 15, 1554, Desoto wrote in his journal that the Pascagoula people ranged as far north as the confluence of the Leaf and Chickasawhay rivers at 30.4, -88.5.</p>
<p>1554年3月15日，德索托在他的日记中写道，帕斯卡古拉人的范围是位于30.4，-88.5的最北边的利夫河和奇卡索河的交汇处。</p>
</blockquote>
<p>提取日期和GPS坐标也许能让你把这个日期和地点、德索托、帕斯卡古拉人以及这两条你念不出名字的河流联系起来。你希望你的机器（和你的大脑）能够将这些事实与更大的事实联系起来——例如，德索托是一个西班牙征服者，而帕斯卡古拉人是一个和平的美国土著部落。而且你希望日期和地点能与正确的“东西”联系起来：分别是德索托和两条河流的交汇处。</p>
<p>这就是大多数人听到自然语言理解这个词时想到的。要理解一个语句，你需要能够提取关键的信息，并将其与相关知识关联起来。对于机器来说，你将这些知识存储在一个图谱中，也称为知识库。你的知识图谱的边就是事物之间的关系。而你的知识图谱的节点就是在你的语料库中找到的名词或对象。 你要用来提取这些关系（或关系）的模式是一种subject - verb - object这样的模式。为了识别这些模式，你需要你的NLP管道知道句子中每个词的词性。</p>
<h3 id="11-4-1-词性（POS）标记">11.4.1 词性（POS）标记</h3>
<p>POS标记可以通过语言模型来完成，这些语言模型具有包含所有可能词性的单词字典。然后，他们可以对正确标记的句子进行训练，以识别新句子和字典中的其他单词中的词性。NLTK和spaCy都实现了POS标记功能。你在这里会使用spaCy，因为它更快、更准确。请看下面的列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> spacy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>en_model = spacy.load(<span class="string">&quot;en_core_web_sm&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sentence = (<span class="string">&quot;In 1541 Desoto wrote in his journal that the Pascagoula people&quot;</span> + <span class="string">&quot;ranged as far north as the confluence of the Leaf and Chickasawhay rivers at 30.4, -88.5.&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parsed_sent = en_model(sentence)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parsed_sent.ents</span><br><span class="line">(<span class="number">1541</span>, Desoto, Pascagoula, Leaf, Chickasawhay, <span class="number">30.4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27; &#x27;</span>.join([<span class="string">&#x27;&#123;&#125;_&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(tok, tok.tag_) <span class="keyword">for</span> tok <span class="keyword">in</span> parsed_sent])</span><br><span class="line"><span class="string">&#x27;In_IN 1541_CD Desoto_NNP wrote_VBD in_IN his_PRP$ journal_NN that_IN the_DT Pascagoula_NNP people_NNS ranged_VBD as_RB far_RB north_RB as_IN the_DT confluence_NN of_IN the_DT Lea f_NNP and_CC Chickasawhay_NNP rivers_VBZ at_IN 30.4_CD ,_, -88.5_NFP ._.&#x27;</span></span><br></pre></td></tr></table></figure>
<p>因此，为了建立你的知识图谱，你需要弄清楚哪些对象（名词短语）应该配对。你想把日期“1554年3月15日“与命名实体Desoto配对。然后你可以将这两个字符串（名词短语）解析为指向你知识库中的对象。1554年3月15日可以转换为具有归一化表示的datetime.date对象。</p>
<p>spaCy-parsed句子还包含嵌套字典中的依存树。而spacy.displacy可以生成一个可扩展的矢量图形SVG字符串（或一个完整的HTML页面），它可以在浏览器中作为图像查看。这种可视化可以帮助您找到使用该树创建标签模式以进行关系提取的方法。请看下面的列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> spacy.displacy <span class="keyword">import</span> render</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sentence = <span class="string">&quot;In 1541 Desoto wrote in his journal about the Pascagoula.&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>parsed_sent = en_model(sentence)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;pascagoula.html&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="meta">... </span>f.write(render(docs=parsed_sent, page=<span class="literal">True</span>, options=<span class="built_in">dict</span>(compact=<span class="literal">True</span>)))</span><br></pre></td></tr></table></figure>
<p>这个短句的依存树显示名词短语“The Pascagoula”是主语“Desoto”关系“met”的宾语（见图11.2）。两个名词都被标记为专有名词。</p>
<img src="https://i.loli.net/2021/04/13/oF3AcQ9CBVrps1X.png"/>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">token_dict</span>(<span class="params">token</span>):</span></span><br><span class="line"><span class="meta">... </span>	<span class="keyword">return</span> OrderedDict(ORTH=token.orth_, LEMMA=token.lemma_, POS=token.pos_, TAG=token.tag_, DEP=token.dep_)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">doc_dataframe</span>(<span class="params">doc</span>):</span></span><br><span class="line"><span class="meta">... </span>	<span class="keyword">return</span> pd.DataFrame([token_dict(tok) <span class="keyword">for</span> tok <span class="keyword">in</span> doc])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>doc_dataframe(en_model(<span class="string">&quot;In 1541 Desoto met the Pascagoula.&quot;</span>))</span><br><span class="line">         ORTH       LEMMA    POS  TAG    DEP</span><br><span class="line"><span class="number">0</span>          In          <span class="keyword">in</span>    ADP   IN   prep</span><br><span class="line"><span class="number">1</span>        <span class="number">1541</span>        <span class="number">1541</span>    NUM   CD   pobj</span><br><span class="line"><span class="number">2</span>      Desoto      desoto   NOUN   NN  nsubj</span><br><span class="line"><span class="number">3</span>         met        meet   VERB  VBD   ROOT</span><br><span class="line"><span class="number">4</span>         the         the    DET   DT    det</span><br><span class="line"><span class="number">5</span>  Pascagoula  Pascagoula  PROPN  NNP   dobj</span><br><span class="line"><span class="number">6</span>           .           .  PUNCT    .  punct</span><br></pre></td></tr></table></figure>
<p>现在您可以看到POS或TAG特性的序列，它们将构成一个良好的模式。如果您正在查找人员和组织之间的“has meet”关系，您可能希望允许使用诸如“PROPN met PROPN”、“PROPN met the PROPN”、“PROPN met the PROPN”、“PROPN met with the PROPN”和“PROPN frequency meeting with PROPN”之类的模式。您可以分别指定这些模式中的每一个，或者尝试使用一些*或者？专有名词之间的“任意词”模式的运算符：</p>
<blockquote>
<p>‘PROPN ANYWORD? met ANYWORD? ANYWORD? PROPN’</p>
</blockquote>
<p>spaCy中的模式比前面的伪代码更强大、更灵活，因此您必须更详细地解释您想要匹配的word特性。在spaCy模式规范中，您可以使用字典来捕获要为每个标记或单词匹配的所有标记，如下面的清单所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pattern = [[&#123;<span class="string">&#x27;TAG&#x27;</span>: <span class="string">&#x27;NNP&#x27;</span>, <span class="string">&#x27;OP&#x27;</span>: <span class="string">&#x27;+&#x27;</span>&#125;, [&#123;<span class="string">&#x27;IS_ALPHA&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;OP&#x27;</span>: <span class="string">&#x27;*&#x27;</span>&#125;],</span><br><span class="line"><span class="meta">... </span>	[&#123;<span class="string">&#x27;LEMMA&#x27;</span>: <span class="string">&#x27;meet&#x27;</span>&#125;],</span><br><span class="line"><span class="meta">... </span>	[&#123;<span class="string">&#x27;IS_ALPHA&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;OP&#x27;</span>: <span class="string">&#x27;*&#x27;</span>&#125;, &#123;<span class="string">&#x27;TAG&#x27;</span>: <span class="string">&#x27;NNP&#x27;</span>, <span class="string">&#x27;OP&#x27;</span>: <span class="string">&#x27;+&#x27;</span>&#125;]]</span><br></pre></td></tr></table></figure>
<p>然后可以从解析的句子中提取所需的标记标记，如下面的清单所示。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> spacy.matcher <span class="keyword">import</span> Matcher</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>doc = en_model(<span class="string">&quot;In 1541 Desoto met the Pascagoula.&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>matcher = Matcher(en_model.vocab)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>matcher.add(<span class="string">&#x27;met&#x27;</span>, [pattern])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = matcher(doc)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">[(<span class="number">12280034159272152371</span>, <span class="number">2</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>doc[m[<span class="number">0</span>][<span class="number">1</span>]:m[<span class="number">0</span>][<span class="number">2</span>]]</span><br><span class="line">Desoto met the Pascagoula</span><br></pre></td></tr></table></figure>
<p>所以你从创建pattern的原始句子中提取了一个匹配项，但是维基百科中类似的句子呢？请参见下面的列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>doc = en_model(<span class="string">&quot;October 24: Lewis and Clark met their first Mandan Chief, Big White.&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = matcher(doc)[<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">(<span class="number">12280034159272152371</span>, <span class="number">3</span>, <span class="number">11</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>doc[m[<span class="number">1</span>]:m[<span class="number">2</span>]]</span><br><span class="line">Lewis <span class="keyword">and</span> Clark met their first Mandan Chief</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>doc = en_model(<span class="string">&quot;On 11 October 1986, Gorbachev and Reagan met at a house&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>matcher(doc)</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<p>您需要添加第二个模式，以允许动词出现在主语和宾语名词之后，如下面的清单所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>doc = en_model(<span class="string">&quot;On 11 October 1986, Gorbachev and Reagan met at a house&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = [&#123;<span class="string">&#x27;TAG&#x27;</span>: <span class="string">&#x27;NNP&#x27;</span>, <span class="string">&#x27;OP&#x27;</span>: <span class="string">&#x27;+&#x27;</span>&#125;, &#123;<span class="string">&#x27;LEMMA&#x27;</span>: <span class="string">&#x27;and&#x27;</span>&#125;, &#123;<span class="string">&#x27;TAG&#x27;</span>: <span class="string">&#x27;NNP&#x27;</span>, <span class="string">&#x27;OP&#x27;</span>: <span class="string">&#x27;+&#x27;</span>&#125;, &#123;<span class="string">&#x27;IS_ALPHA&#x27;</span>: <span class="literal">True</span>, <span class="string">&#x27;OP&#x27;</span>: <span class="string">&#x27;*&#x27;</span>&#125;, &#123;<span class="string">&#x27;LEMMA&#x27;</span>: <span class="string">&#x27;meet&#x27;</span>&#125;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>matcher.add(<span class="string">&#x27;met&#x27;</span>, <span class="literal">None</span>, pattern)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = matcher(doc)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">[(<span class="number">14332210279624491740</span>, <span class="number">5</span>, <span class="number">9</span>),</span><br><span class="line">(<span class="number">14332210279624491740</span>, <span class="number">5</span>, <span class="number">11</span>),</span><br><span class="line">(<span class="number">14332210279624491740</span>, <span class="number">7</span>, <span class="number">11</span>),</span><br><span class="line">(<span class="number">14332210279624491740</span>, <span class="number">5</span>, <span class="number">12</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>doc[m[-<span class="number">1</span>][<span class="number">1</span>]:m[-<span class="number">1</span>][<span class="number">2</span>]]</span><br><span class="line">Gorbachev <span class="keyword">and</span> Reagan met at a house</span><br></pre></td></tr></table></figure>
<p>所以现在你有了你的实体和关系。您甚至可以构建一个模式，该模式对中间的动词（“met”）限制较少，对两边的人和组的名称限制更多。这样做可能会让你识别出暗示一个人或一组人遇到了另一个人或另一组人的其他动词，比如动词“知道”，甚至是被动短语，比如“有过一次谈话”或“变得熟悉”。然后你可以使用这些新动词来为两边的新专有名词添加关系。但你可以看到你是如何偏离你的种子关系模式的最初含义的。这就是所谓的语义漂移。</p>
<p>幸运的是，spaCy不仅用词性和依存关系树信息来标记解析文档中的单词，而且还用词性模式匹配器（如清单11.18所示）将多个模式结合起来，以获得更健壮的模式匹配器该模式不匹配Wikipedia中句子的任何子字符串。添加附加图案而不删除以前的图案。这里的“met”是一个任意键。随便你怎么命名你的图案。“+”运算符增加了重叠替代匹配的数量。最长的匹配是匹配列表中的最后一个。357提取关系（relations）还提供Word2vec单词向量。您可以使用此向量来防止连接动词和两边的专有名词偏离种子模式的原始含义太远。</p>
<h3 id="11-4-2实体名称规范化">11.4.2实体名称规范化</h3>
<p>实体的规范化表示通常是字符串，即使对于日期等数字信息也是如此。此日期的标准化ISO格式为“1541-01-01”。实体的标准化表示使您的知识库能够将世界上在同一日期发生的所有不同事件连接到图形中的同一节点（实体）。对其他命名实体也会这样做。</p>
<p>你应该纠正单词的拼写，并尝试解决物体、动物、人、地方等名称的歧义。规范化命名实体和解决歧义通常被称为共指消解或回指消解，特别是对于依存上下文的代词或其他“名称”。这类似于我们在第2章讨论的lemmatization。命名实体的规范化可确保拼写和命名变体不会因混淆、冗余的名称而污染实体名称的词汇表。例如，“Desoto”在一个特定的文档中至少可以用五种不同的方式来表达：</p>
<ul>
<li>“de Soto”</li>
<li>“Hernando de Soto”</li>
<li>“Hernando de Soto (c. 1496/1497–1542), Spanish conquistador”</li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hernando_de_Soto">https://en.wikipedia.org/wiki/Hernando_de_Soto</a> (a URI)</li>
<li>A numerical ID for a database of famous and historical people</li>
</ul>
<p>类似地，您的规范化算法可以选择这些形式中的任何一种。知识图应该以相同的方式规范化每种实体，以防止同一类型的多个不同实体共享相同的名称。您不希望多个人名引用同一个自然人。更重要的是，无论是在向知识库中写入新事实时，还是在阅读或查询知识库时，规范化都应该始终如一地应用。如果在填充数据库之后决定更改规范化方法，则应该“迁移”或更改知识中现有实体的数据，以遵循新的规范化方案。无模式数据库（键值存储）与用于存储知识图或知识库的数据库一样，不能免除关系数据库的迁移责任。毕竟，无模式数据库是关系数据库的接口包装器。您的规范化实体还需要“is-a”关系来将它们连接到定义实体类型或类别的实体类别。这些“is-a”关系可以看作是标记，因为每个实体可以有多个“is-a”关系。就像7，这是积极研究的主题：<a target="_blank" rel="noopener" href="https://nlp.stanford.edu/pubs/structuredVS.pdf%E3%80%82%E5%A6%82%E6%9E%9C%E6%82%A8%E6%83%B3%E5%B0%86%E4%BA%BA%E5%90%8D%E6%88%96POS%E6%A0%87%E7%AD%BE%E3%80%81%E6%97%A5%E6%9C%9F%E5%92%8C%E5%85%B6%E4%BB%96%E7%A6%BB%E6%95%A3%E7%9A%84%E6%95%B0%E5%AD%97%E5%AF%B9%E8%B1%A1%E5%90%88%E5%B9%B6%E5%88%B0%E6%82%A8%E7%9A%84%E7%9F%A5%E8%AF%86%E5%BA%93%E4%B8%AD%EF%BC%8C%E5%88%99%E9%9C%80%E8%A6%81%E5%AF%B9%E5%AE%83%E4%BB%AC%E8%BF%9B%E8%A1%8C%E8%A7%84%E8%8C%83%E5%8C%96%E3%80%82%E5%AE%9E%E4%BD%93%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E9%9C%80%E8%A6%81%E4%BB%A5%E6%AD%A3%E5%B8%B8%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AD%98%E5%82%A8%E5%90%97%EF%BC%9F">https://nlp.stanford.edu/pubs/structuredVS.pdf。如果您想将人名或POS标签、日期和其他离散的数字对象合并到您的知识库中，则需要对它们进行规范化。实体之间的关系需要以正常的方式存储吗？</a></p>
<h3 id="11-4-3关系规范化和提取">11.4.3关系规范化和提取</h3>
<p>现在需要一种方法来规范关系，以识别实体之间的关系类型。这样做可以让你找到日期和人之间的所有生日关系，或者历史事件发生的日期，例如“Hernando de Soto”和“Pascagola people”之间的遭遇。您需要编写一个算法来为您的关系选择正确的标签。这些关系可以有一个层次名称，例如“发生在/大约”和“发生在/确切地”以允许您找到特定的关系或关系类别。您还可以使用该关系的“置信度”、“概率、权重或标准化频率”（术语/词的ANLO  GOU到TF-IDF）的数值属性标记这些关系。每次从新文本中提取的事实证实或与数据库中存在的事实相矛盾时，都可以调整这些置信值。现在，您需要一种方法来匹配可以找到这些关系的模式。</p>
<h3 id="11-4-4字型字模式">11.4.4字型字模式</h3>
<p>与正则表达式一样，而非字符。您没有字符类，而是有单词类。例如，您可能会有一个单词模式决定来匹配所有的单数名词（“NN”POS标记），8这通常是通过机器学习完成的。有些种子句子被标记了一些正确的关系（事实）从这些句子中提取。POS模式可以用来找到类似的句子，在这些句子中主语和宾语，甚至关系都可能发生变化。无论您希望匹配多少模式，您都可以使用spaCy包两种不同的方法来匹配O（1）（恒定时间）中的这些模式：”“。任何单词/标记序列模式的phrasether 9™POS标记序列模式匹配器10，以确保新句子中找到的新关系与原始种子（例如）真正类似（示例）关系，你经常需要约束主语，关系，和宾语的意思，以类似于种子句。最好的方法是用一些向量表示单词的意思。这个响吗？第4章讨论的词向量是目前应用最广泛的词义表示方法之一。它们有助于最小化语义漂移。</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://livebook.manning.com/book/natural-language-processing-in-action/chapter-11/1">Chapter 11. Information extraction (named entity extraction and question answering) - Natural Language Processing in Action: Understanding, analyzing, and generating text with Python (manning.com)</a></p>

    </div>

    
    
    
      
  <div class="popular-posts-header">猜你喜欢</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\information-retrieval-3\" rel="bookmark">《自然语言处理综论》第17章-信息抽取（下）</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\information-retrieval-2\" rel="bookmark">《自然语言处理综论》第17章-信息抽取（中）</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\information-retrieval-1\" rel="bookmark">《自然语言处理综论》第17章-信息抽取（上）</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\information-retrieval\" rel="bookmark">信息抽取技术综述</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\spacy-1\" rel="bookmark">spaCy超强指南之文本预处理和语言特征表</a></div>
    </li>
  </ul>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>鸽鸽
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://nlpcourse.cn/information-retrieval-4/" title="信息抽取">http://nlpcourse.cn/information-retrieval-4/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/images/wechat_channel.jpg">
            <span class="icon">
              <i class="fab fa-weixin"></i>
            </span>

            <span class="label">微信</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/nlp/" rel="tag"><i class="fa fa-tag"></i> nlp</a>
              <a href="/tags/IR/" rel="tag"><i class="fa fa-tag"></i> IR</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/flask-2/" rel="prev" title="一文读懂Flask Web开发实战！">
      <i class="fa fa-chevron-left"></i> 一文读懂Flask Web开发实战！
    </a></div>
      <div class="post-nav-item">
    <a href="/psycho-linguistics/" rel="next" title="心理语言学：资源和知识整理">
      心理语言学：资源和知识整理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1-1-%E7%9F%A5%E8%AF%86%E5%BA%93-knowledge-base"><span class="nav-number">1.</span> <span class="nav-text">11.1.1 知识库  (knowledge base)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1-2-%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%96"><span class="nav-number">2.</span> <span class="nav-text">11.1.2 信息抽取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-2-%E4%BF%A1%E6%81%AF%E6%8A%BD%E5%8F%96%E4%BD%9C%E4%B8%BAML%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96"><span class="nav-number">3.</span> <span class="nav-text">11.2.2 信息抽取作为ML特征提取</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-3-%E5%80%BC%E5%BE%97%E6%8F%90%E5%8F%96%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="nav-number"></span> <span class="nav-text">11.3 值得提取的信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-1-%E6%8F%90%E5%8F%96GPS%E4%BD%8D%E7%BD%AE"><span class="nav-number">1.</span> <span class="nav-text">11.3.1 提取GPS位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-2-%E6%8F%90%E5%8F%96%E6%97%A5%E6%9C%9F"><span class="nav-number">2.</span> <span class="nav-text">11.3.2 提取日期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-4-%E6%8F%90%E5%8F%96%E5%85%B3%E7%B3%BB%EF%BC%88relation%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">11.4 提取关系（relation）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4-1-%E8%AF%8D%E6%80%A7%EF%BC%88POS%EF%BC%89%E6%A0%87%E8%AE%B0"><span class="nav-number">1.</span> <span class="nav-text">11.4.1 词性（POS）标记</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4-2%E5%AE%9E%E4%BD%93%E5%90%8D%E7%A7%B0%E8%A7%84%E8%8C%83%E5%8C%96"><span class="nav-number">2.</span> <span class="nav-text">11.4.2实体名称规范化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4-3%E5%85%B3%E7%B3%BB%E8%A7%84%E8%8C%83%E5%8C%96%E5%92%8C%E6%8F%90%E5%8F%96"><span class="nav-number">3.</span> <span class="nav-text">11.4.3关系规范化和提取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-4-4%E5%AD%97%E5%9E%8B%E5%AD%97%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">11.4.4字型字模式</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="鸽鸽"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">鸽鸽</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">31</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/MissFreak" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;MissFreak" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:1360759791@qq.com" title="E-Mail → mailto:1360759791@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.cnblogs.com/tuyuge/" title="cnblogs → https:&#x2F;&#x2F;www.cnblogs.com&#x2F;tuyuge&#x2F;" rel="noopener" target="_blank"><i class="fa fa-blog fa-fw"></i>cnblogs</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/tu-tu-70-60-86" title="zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;tu-tu-70-60-86" rel="noopener" target="_blank"><i class="fa fa-book fa-fw"></i>zhihu</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">鸽鸽</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">264k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:01</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
